0. ## **读模式操作**
#### **代码部分：**
    f = open(file='文件路径', mode='r', encoding='utf-8') 
    data = f.read() 
    f.close()
#### **讲解部分：**
    第一步：用只读模式和utf-8编码打开文件。但如果文件的编码并非utf-8,会报出UnicodeDecodeError类错误。
    第二步：读取文件内容放入内存中。
    read()还支持一个参数size。该参数是从文件中读取的字节数。如data = f.read(2)那就data变量中只会赋值打开文件中的前2个字符。这个参数的好处是，当文件的大小大于内存时，可以限制读取文件的大小。 
    第三步：关闭文件

## **二进制模式**
    直接将文件已二进制的方式进行读取。主要用于视频、图片和网络传输的文本使用。
#### **代码部分：**
     f = open(file='文件路径', mode='rb') 
     data = f.read() 
     f.close()
#### **讲解部分：**
    第一步：用只读二进制模式打开文件。
    第二步：读取文件内容放入内存中。
    read()还支持一个参数size。该参数是从文件中读取的字节数。如data = f.read(2)那就data变量中只会赋值打开文件中的前2个字符。这个参数的好处是，当文件的大小大于内存时，可以限制读取文件的大小


## **使用二进制检测文件编码 - chardet模块**
#### **代码部分：**
    import chardet
    result = chardet.detect(open(file='文件路径', mode='rb').read())
    print(result)
### **输出内容：**
    {'encoding': 'utf-8', 'confidence': 0.7525, 'language': ''}
    1.) encoding：解析出来可能的编码格式。
    2.）confidence: 确信的程度。
    3.）language：可能使用的语言。
#### **讲解部分：**
    第一步：导入chardet模块
    第二步：将文件打开，并读取内容后。使用chardet.detect方法进行预判
    第三步：打印结果
    

## **写模式操作**
#### **代码部分：**
    f = open(file='文件路径', mode='w', encoding='gbk')
    f.write('输入字符串')
    f.close()
#### **讲解部分：**
    第一步：用只写模式和gbk编码打开文件。不管文件是否存在，都会创建文件。
    第二步：调用write方法，方法中的字符串以gbk的方式存入文件中。
    第三步：关闭文件
    

## **二进制写模式操作**
    直接将文件已二进制的方式进行写入。主要用于视频、图片和网络传输的文本使用。
#### **代码部分：**
    f = open(file='文件路径', mode='wb')
    f.write('输入字符串'.encode('utf-8'))
    f.close()
#### **讲解部分：**
    第一步：用只写二进制模式打开文件。如果文件没有创建，就会创建文件。
    第二步：调用write方法，方法中的字符串以utf-8的方式进行编码存入文件。
    第三步：关闭文件
#### **注意：**
    f = open(file='test1', mode='wb')
    f.write('test')
    f.close()
    如上的代码在二进制模式中会报TypeError类型错误。报错信息如下：
    Traceback (most recent call last):
    File "/development/homework/test.py", line 2, in <module>
        f.write('test')
    TypeError: a bytes-like object is required, not 'str'
    该错误的意思是，需要使用一个二进制的对象去进行写入，而非一个字符串。
    所以在write方法中使用encode参数。将字符串进行编码成而二进制
    
## **追加模式**
        打开一个文件进行追加。 如果文件存在，则文件指针位于文件末尾。
    将会在文件的最后一个字符后追加。如果文件不存在，它将创建一个新文件进行写入。
#### **代码部分：**
    f = open(file='文件路径', mode='a', encoding='utf-8')
    f.write('\n输入字符串')
    f.close()
#### **讲解部分：**
    第一步：用追加模式和utf-8编码打开文件。如果文件没有创建，就会创建文件。
    第二步：调用write方法，将方法中的字符串写入文件。如需要另起一行就需要在字符串前最佳\n(回车符)。
    第三步：关闭文件    

## **二进制追加模式**
        以二进制的方式打开一个文件进行追加。 如果文件存在，则文件指针位于文件末尾。
    将会在文件的最后一个字符后追加。如果文件不存在，它将创建一个新文件进行写入。
#### **代码部分：**
    f = open(file='文件路径', mode='a')
    f.write('\n输入字符串'.encode('utf-8'))
    f.close()
#### **讲解部分：**
    第一步：用二进制追加模式打开文件。如果文件没有创建，就会创建文件。
    第二步：调用write方法的encode参数，将方法中的字符串编码成utf-8写入文件。如需要另起一行就需要在字符串前最佳\n(回车符)。
    第三步：关闭文件 
    
## **读写混合模式**
        先读后写模式。   
#### **代码部分：**
    f = open(file='文件路径', mode='r+', encoding='utf-8')
    print('content:', f.read())
    f.write('\n输入字符串')
    f.write('\n输入字符串')
    print('new content:', f.read())
    f.close()
#### **输出内容：**
    content: www.baidu.com
    www.google.com

    new content: utf-8
#### **讲解部分：**
    第一步：用读写模式和utf-8编码打开文件。如果文件没有创建，就会创建文件。
    第二步：先读取文件，在文件的末尾字符后写入新行（类似于追加模式）。
    第三步：关闭文件 
#### **注意**
    我们可能发现。第一次打印文件时，打印处理还没写入时文件的内容。但写入后的第二次打印，却没有打印出添加的内容。
    这与文件处理的光标有关。请阅览后面的“文件操作：光标”章节

## **写读混合模式** 
    先写后读模式。 
#### **代码部分：**
    f = open(file='文件路径', mode='w+', encoding='utf-8')
    f.write('\n输入字符串')
    f.write('\n输入字符串')
    print('new content:', f.read())
    f.close()
#### **输出内容**
    new content:
#### **讲解部分：**
    第一步：用写读模式和utf-8编码打开文件。无论文件是否存在，都会创建文件。
    第二步：先写入文件，再读取文件。
    第三步：关闭文件 
#### **注意**
    我们可能发现。最后的输出中并没有将文件中添加的内容显示出来。
    这与文件处理的光标有关。请阅览后面的“文件操作：光标”章节
    

## **文件操作：光标**

## **总结**
#### **打开文件**
    语法
    file object = open(file_name [, access_mode][, buffering])

    这里是参数详细信息 -
    * file_name - file_name参数是一个字符串值，指定要访问的文件的名称。
    * access_mode - access_mode确定文件打开的模式，即读取，写入，追加等。可能的值的完整列表如下表所示。 这是一个可选参数，默认文件访问模式为(r - 也就是只读)。
    * buffering - 如果buffering值设置为0，则不会发生缓冲。 如果缓冲值buffering为1，则在访问文件时执行行缓冲。如果将缓冲值buffering指定为大于1的整数，则使用指定的缓冲区大小执行缓冲操作。如果为负，则缓冲区大小为系统默认值(默认行为)。
## **文件操作的所有模式**
<table>
<thead>
<tr>
<th>编号</th>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>r</code></td>
<td>打开的文件为只读模式。文件指针位于文件的开头，这是默认模式。</td>
</tr>
<tr>
<td>2</td>
<td><code>rb</code></td>
<td>打开仅用二进制格式读取的文件。文件指针位于文件的开头，这是默认模式。</td>
</tr>
<tr>
<td>3</td>
<td><code>r+</code></td>
<td>打开读写文件。文件指针放在文件的开头。</td>
</tr>
<tr>
<td>4</td>
<td><code>rb+</code></td>
<td>以二进制格式打开一个用于读写文件。文件指针放在文件的开头。</td>
</tr>
<tr>
<td>5</td>
<td><code>w</code></td>
<td>打开仅供写入的文件。 如果文件存在，则覆盖该文件。 如果文件不存在，则创建一个新文件进行写入。</td>
</tr>
<tr>
<td>6</td>
<td><code>wb</code></td>
<td>打开仅用二进制格式写入的文件。如果文件存在，则覆盖该文件。 如果文件不存在，则创建一个新文件进行写入。</td>
</tr>
<tr>
<td>7</td>
<td><code>w+</code></td>
<td>打开写入和取读的文件。如果文件存在，则覆盖现有文件。 如果文件不存在，创建一个新文件进行阅读和写入。</td>
</tr>
<tr>
<td>8</td>
<td><code>wb+</code></td>
<td>打开一个二进制格式的写入和读取文件。 如果文件存在，则覆盖现有文件。 如果文件不存在，创建一个新文件进行阅读和写入。</td>
</tr>
<tr>
<td>9</td>
<td><code>a</code></td>
<td>打开一个文件进行追加。 如果文件存在，则文件指针位于文件末尾。也就是说，文件处于追加模式。如果文件不存在，它将创建一个新文件进行写入。</td>
</tr>
<tr>
<td>10</td>
<td><code>ab</code></td>
<td>打开一个二进制格式的文件。如果文件存在，则文件指针位于文件末尾。 也就是说，文件处于追加模式。如果文件不存在，它将创建一个新文件进行写入。</td>
</tr>
<tr>
<td>11</td>
<td><code>a+</code></td>
<td>打开一个文件，用于追加和阅读。 如果文件存在，则文件指针位于文件末尾。 文件以附加模式打开。 如果文件不存在，它将创建一个新文件进行阅读和写入。</td>
</tr>
<tr>
<td>12</td>
<td><code>ab+</code></td>
<td>打开一个二进制格式的附加和读取文件。 如果文件存在，则文件指针位于文件末尾。文件以附加模式打开。如果文件不存在，它将创建一个新文件进行读取和写入。</td>
</tr>
</tbody>
</table>

