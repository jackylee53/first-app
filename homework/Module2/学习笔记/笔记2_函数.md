## **位置参数**
&emsp;&emsp;调用函数时，参数值与参数的位置一一对应。
## **关键字参数**
&emsp;&emsp;调用函数时，指定参数对应的参数值。
## **非固定参数**
#### **语法：**
    def func(self, *args, **kwargs)
如下为参数详解：
* *args：调用函数时，将剩余没有找到的位置参数，都打包成一个元组中导入函数。参数名称不一定要是args，也可以自己定义。如：\*user。但为了规范，请使用\*args
* **kwargs：调用函数时，将没有找到的关键参数，都打包到一个字典中导入函数。参数名称不一定要是kwargs，也可以自己定义。如：\*dict。但为了规范，请使用\*kwargs
#### **代码部分：**
    def func(name, *args, **kwargs):
        print(name, args, kwargs)
    func('henry', 'it', 'hr', address='shanghai', phone='123')
#### **输出内容：**
    henry ('it', 'hr') {'address': 'shanghai', 'phone': '123'}
* 我们可以发现，由于'henry'是name的位置参数，所以被name参数调用。
* 'it', 'hr'由于没有位置参数，被args参数调用，并且封装为一个元组。
* address='shanghai', phone='123'是没有在函数中定义的关键字参数。所以被kwargs参数调用。并封装为一个字典
#### **讲解部分：**
    第一步：定义一个带有name, *args, **kwargs参数的func函数。
    第二步：打印name，args，kwargs
    第三步：调用func函数并给函数中的参数赋值
#### **其他**
&emsp;&emsp;有时我们可能已经预先定义好了一个字典、列表、元组。希望导入到函数的args、kwargs中该怎么办？
#### **代码部分：**
    def func(name, *args, **kwargs):
        print(name, args, kwargs)
    list = ['it', 'hr']
    tup = ('it', 'hr')
    dict = {'address': 'shanghai', 'phone': 123}
    func('henry', *list, **dict)
    func('tom',*tup, **dict)
#### **输出内容：**
    henry ('it', 'hr') {'address': 'shanghai', 'phone': 123}
    tom ('it', 'hr') {'address': 'shanghai', 'phone': 123}
#### **讲解部分：**
    只需要在调用函数时，在参数前加一个“*”号，就被args参数调用。加“**”，就被kwargs参数调用

## **在函数里修改全局变量——慎用**
&emsp;&emsp;默认函数中无法修改全局变量的内容。但可以在函数中使用global语句。global语句可以起到声明变量作用域，也可以理解为能修改重新定义全局变量的作用
#### **代码部分：**
    name = 'henry'
    def func():
        global name
        name = 'jenry'
        print('函数中变量:',name)
    func()
    print('全局变量：',name)
#### **输出内容：**
    函数中变量: jenry
    全局变量： jenry
#### **讲解部分：**
    使用gloabl语句后，全局变量就进行了修改。
#### **注意**
&emsp;&emsp;如果全局变量是一个列表、字典、集合、对象哪。里面的内容是否修改。

**代码部分：**

    name = ['henry', 'jenry', 'tom']
    def func():
    name[1] = 'mike'
    print('函数中变量:',name)
    func()
    print('全局变量：',name)
**输出内容：**

    函数中变量: ['henry', 'mike', 'tom']
    全局变量： ['henry', 'mike', 'tom']
**讲解部分：**

    虽然全局变量在一块不能修改的内存区块中，但列表、字典、集合、对象中的内容。却在另外的一块可以修改的内存区块中。所以可以修改。