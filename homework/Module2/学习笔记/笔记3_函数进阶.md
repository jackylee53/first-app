## **第一章：命名空间**
&emsp;&emsp;Python使用叫做命名空间的东西来记录变量的轨迹。命名空间是一个字典（dictionary） ，它的键就是变量名，它的值就是那些变量的值(其实并非实际的值，而是值所在的内存地址)。<br>
#### **一、命名空间的种类**
&emsp;&emsp;在一个 Python 程序中的任何一个地方，都存在几个可用的命名空间。
1. local：每个函数都有着自已的命名空间，叫做局部命名空间，它记录了函数的变量，包括函数的参数和局部定义的变量。
2. global：每个模块拥有它自已的命名空间，叫做全局命名空间，它记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。
3. build-in：还有就是内置命名空间，任何模块均可访问它，它存放着内置的函数和异常。

#### **二、命名空间：作用域的查找顺序**
&emsp;&emsp;python在运行时候变量在命名空间作用域中查找顺序（遵从legb规则）以此是:<br>
local（局部命名空间）-->enclosing（外部嵌套函数的命名空间）-->global（全局命名空间）-->build-in（内建模块的命名空间）
1. local(局部命名空间)：特指当前函数或类中的方法。
2. enclosing(外部嵌套函数的名字空间)：如函数或类有嵌套关系，会在父函数或类的命名空间作用域中查找。
3. global（全局命名空间）：特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python 将使用它然后停止搜索。
4. build-in（内置命名空间）：对每个模块都是全局的。作为最后的尝试，Python 将假设 x 是内置函数或变量。
5. 如果如上都找不到，它将放弃查找并引发一个 NameError 异常，如，NameError: name 'aa' is not defined。

#### **三、命名空间的生命周期**
&emsp;&emsp;不同的命名空间在不同的时刻创建，有不同的生存期。<br>
1. 内置命名空间在 Python 解释器启动时创建，会一直保留，不被删除。
2. 模块的全局命名空间在模块定义被读入时创建，通常模块命名空间也会一直保存到解释器退出。
3. 当函数被调用时创建一个局部命名空间，当函数返回结果或抛出异常时，被删除。每一个递归调用的函数都拥有自己的命名空间。

&emsp;&emsp;Python 的一个特别之处在于其赋值操作总是在最里层的作用域。赋值不会复制数据——只是将命名绑定到对象。<br>
###### 示例：
    i=1
    def func2():
        i=i+1
    func2();
###### 输出内容：
    UnboundLocalError: local variable 'i' referenced before assignment
&emsp;&emsp;由于创建命名空间时，python会检查代码并填充局部命名空间。在python运行那行代码之前，就发现了对i的赋值，并把它添加到局部命名空间中。当函数执行时，python解释器认为i在局部命名空间中但没有值，所以会产生错误。

#### **四、命名空间的访问方法**
##### **1. 局部命名空间可以 locals()内部函数来访问。**
&emsp;&emsp;locals 返回一个名字/值对的字典。这个字典的键是字符串形式的变量名字，字典的值是变量的实际值。
###### 示例：
    def func1(i, str ):
        x = 12345
        print(locals())
    func1(1 , "first")
###### 输出内容：
    {'str': 'first', 'x': 12345, 'i': 1}

 
##### **2. 全局命名空间可以通过 globals()内部函数来访问。**
###### 示例：
    gstr = "global string"
    def func1(i, info):
        x = 12345
    print(globals())
###### 输出内容：
    {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x000002167313CC88>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'D:/deployment/first-app/homework/test.py', '__cached__': None, 'gstr': 'global string', 'func1': <function func1 at 0x0000021671553E18>}
 
#### **五、其他**
&emsp;&emsp;扩展一下模块导入from module import 和 import module 之间的不同。
1. 使用 import module，模块自身被导入，但是它保持着自已的名字空间，module.function来访问它的函数或属性。
2. 但是使用 from module import function，实际上是从另一个模块中将指定的函数和属性导入到您自己的名字空间。
 
## **第二章：闭包**
&emsp;&emsp;闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，闭包是由函数和与其相关的引用环境组合而成的实体。
#### **一、Python创建闭包**
##### **示例：**
    def func1():
        prefix = "Good Morning"
        def func2(name):
            print(prefix, name)
        return func2
    f = func()
    f("henry")
    f("tom")
##### **输出内容**
    Good Morning henry
    Good Morning tom
&emsp;&emsp;func1函数中的变量”prefix”并没有随着函数的退出而销毁，反而是生命周期得到了延长。这就是闭包

#### **二、闭包的原理**
##### ** __closure__属性**
&emsp;&emsp;在Python中，函数对象有一个__closure__属性，我们可以通过这个属性看看闭包的一些细节。
##### **示例：**
    def func():
        prefix = "Good Morning"
        def func2(name):
            print(prefix, name)
        return func2
    f = func()
    f("henry")
    f("tom")
    print(dir(f))
    print(f.__closure__)
    print(type(f.__closure__[0]))
    print(f.__closure__[0].cell_contents)
##### **输出内容：**
    Good Morning henry
    Good Morning tom
    ['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
    (<cell at 0x000002348E96EEE8: str object at 0x0000023490805B30>,)
    <class 'cell'>
    Good Morning
&emsp;&emsp;通过__closure__属性看到，它对应了一个tuple，tuple的内部包含了cell类型的对象。<br>
&emsp;&emsp;对于这个例子，可以得到cell的值（内容）为”Good Morning”，也就是变量”prefix”的值。<br>
&emsp;&emsp;从这里可以看到闭包的原理，当内嵌函数引用了包含它的函数（enclosing function）中的变量后，这些变量会被保存在enclosing function的__closure__属性中，成为enclosing function本身的一部分；也就是说，这些变量的生命周期会和enclosing function一样。

##### **三、总结**
&emsp;&emsp;在Python中创建一个闭包可以归结为以下三点：
1. 闭包函数必须有内嵌函数
2. 内嵌函数需要引用该嵌套函数上一级namespace中的变量
3. 闭包函数必须返回内嵌函数
&emsp;&emsp;通过这三点，就可以创建一个闭包。在下章节介绍的Python装饰器，就会使用了闭包这个概念。

## **第三章：装饰器**
装饰器其实就是一个以函数作为参数并返回一个替换函数的可执行函数。让我们从简单的开始，直到能写出实用的装饰器。

Python

>>> def outer(some_func):
...     def inner():
...         print "before some_func"
...         ret = some_func() # 1
...         return ret + 1
...     return inner
>>> def foo():
...     return 1
>>> decorated = outer(foo) # 2
>>> decorated()
before some_func
2
1
2
3
4
5
6
7
8
9
10
11
12
>>> def outer(some_func):
...     def inner():
...         print "before some_func"
...         ret = some_func() # 1
...         return ret + 1
...     return inner
>>> def foo():
...     return 1
>>> decorated = outer(foo) # 2
>>> decorated()
before some_func
2
请仔细看这个装饰器示例。首先，定义了一个带单个参数 some_func 的名为 outer 的函数。然后在 outer 内部定义了一个内嵌函数 inner。inner 函数将打印一行字符串然后调用 some_func，并在 #1 处获取其返回值。在每次 outer 被调用时，some_func 的值可能都会不同，但不论 some_func 是什么函数，都将调用它。最后，inner 返回 some_func() 的返回值加 1。在 #2 处可以看到，当调用赋值给 decorated 的返回函数时，得到的是一行文本输出和返回值 2，而非期望的调用 foo 的返回值 1。

我们可以说变量 decorated 是 foo 的装饰版——即 foo 加上一些东西。事实上，如果写了一个实用的装饰器，可能会想用装饰版来代替 foo，这样就总能得到“附带其他东西”的 foo 版本。用不着学习任何新的语法，通过将包含函数的变量重新赋值就能轻松做到这一点：

Python

>>> foo = outer(foo)
>>> foo # doctest: +ELLIPSIS
<function inner at 0x...>
1
2
3
>>> foo = outer(foo)
>>> foo # doctest: +ELLIPSIS
<function inner at 0x...>
现在任意调用 foo() 都不会得到原来的 foo，而是新的装饰器版！明白了吗？来写一个更实用的装饰器。

想象一个提供坐标对象的库。它们可能主要由一对对的 x、y坐标组成。遗憾的是坐标对象不支持数学运算，并且我们也无法修改源码。然而我们需要做很多数学运算，所以要构造能够接收两个坐标对象的 add 和 sub 函数，并且做适当的数学运算。这些函数很容易实现（为方便演示，提供一个简单的 Coordinate 类）。

Python

>>> class Coordinate(object):
...     def __init__(self, x, y):
...         self.x = x
...         self.y = y
...     def __repr__(self):
...         return "Coord: " + str(self.__dict__)
>>> def add(a, b):
...     return Coordinate(a.x + b.x, a.y + b.y)
>>> def sub(a, b):
...     return Coordinate(a.x - b.x, a.y - b.y)
>>> one = Coordinate(100, 200)
>>> two = Coordinate(300, 200)
>>> add(one, two)
Coord: {'y': 400, 'x': 400}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
>>> class Coordinate(object):
...     def __init__(self, x, y):
...         self.x = x
...         self.y = y
...     def __repr__(self):
...         return "Coord: " + str(self.__dict__)
>>> def add(a, b):
...     return Coordinate(a.x + b.x, a.y + b.y)
>>> def sub(a, b):
...     return Coordinate(a.x - b.x, a.y - b.y)
>>> one = Coordinate(100, 200)
>>> two = Coordinate(300, 200)
>>> add(one, two)
Coord: {'y': 400, 'x': 400}
但是如果 add 和 sub 函数必须有边界检测功能呢？也许只能对正坐标进行加或减，并且返回值也限制为正坐标。如下：

Python

>>> one = Coordinate(100, 200)
>>> two = Coordinate(300, 200)
>>> three = Coordinate(-100, -100)
>>> sub(one, two)
Coord: {'y': 0, 'x': -200}
>>> add(one, three)
Coord: {'y': 100, 'x': 0}
1
2
3
4
5
6
7
>>> one = Coordinate(100, 200)
>>> two = Coordinate(300, 200)
>>> three = Coordinate(-100, -100)
>>> sub(one, two)
Coord: {'y': 0, 'x': -200}
>>> add(one, three)
Coord: {'y': 100, 'x': 0}
但我们希望在不修改 one、two 和 three的基础上，one 和 two 的差值为 {x: 0, y: 0}，one 和 three 的和为 {x: 100, y: 200}。接下来用一个边界检测装饰器来实现这一点，而不用对每个函数里的输入参数和返回值添加边界检测。

Python

>>> def wrapper(func):
...     def checker(a, b): # 1
...         if a.x < 0 or a.y < 0:
...             a = Coordinate(a.x if a.x > 0 else 0, a.y if a.y > 0 else 0)
...         if b.x < 0 or b.y < 0:
...             b = Coordinate(b.x if b.x > 0 else 0, b.y if b.y > 0 else 0)
...         ret = func(a, b)
...         if ret.x < 0 or ret.y < 0:
...             ret = Coordinate(ret.x if ret.x > 0 else 0, ret.y if ret.y > 0 else 0)
...         return ret
...     return checker
>>> add = wrapper(add)
>>> sub = wrapper(sub)
>>> sub(one, two)
Coord: {'y': 0, 'x': 0}
>>> add(one, three)
Coord: {'y': 200, 'x': 100}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
>>> def wrapper(func):
...     def checker(a, b): # 1
...         if a.x < 0 or a.y < 0:
...             a = Coordinate(a.x if a.x > 0 else 0, a.y if a.y > 0 else 0)
...         if b.x < 0 or b.y < 0:
...             b = Coordinate(b.x if b.x > 0 else 0, b.y if b.y > 0 else 0)
...         ret = func(a, b)
...         if ret.x < 0 or ret.y < 0:
...             ret = Coordinate(ret.x if ret.x > 0 else 0, ret.y if ret.y > 0 else 0)
...         return ret
...     return checker
>>> add = wrapper(add)
>>> sub = wrapper(sub)
>>> sub(one, two)
Coord: {'y': 0, 'x': 0}
>>> add(one, three)
Coord: {'y': 200, 'x': 100}
装饰器和之前一样正常运行——返回了一个修改版函数，但在这次示例中通过检测和修正输入参数和返回值，将任何负值的 x 或 y 用 0 来代替，实现了上面的需求。

是否这么做是见仁见智的，它让代码更加简洁：通过将边界检测从函数本身分离，使用装饰器包装它们，并应用到所有需要的函数。可替换的方案是：在每个数学运算函数返回前，对每个输入参数和输出结果调用一个函数，不可否认，就对函数应用边界检测的代码量而言，使用装饰器至少是较少重复的。事实上，如果要装饰的函数是我们自己实现的，可以使装饰器应用得更明确一点。

10. 函数装饰器 @ 符号的应用
Python 2.4 通过在函数定义前添加一个装饰器名和 @ 符号，来实现对函数的包装。在上面代码示例中，用了一个包装的函数来替换包含函数的变量来实现了装饰函数。

Python

>>> add = wrapper(add)
1
>>> add = wrapper(add)
这种模式可以随时用来包装任意函数。但是如果定义了一个函数，可以用 @ 符号来装饰函数，如下：


>>> @ wrapper 
... def add(a, b): 
...     return Coordinate(a.x + b.x, a.y + b.y)
1
2
3
>>> @ wrapper 
... def add(a, b): 
...     return Coordinate(a.x + b.x, a.y + b.y)
值得注意的是，这种方式和简单的使用 wrapper 函数的返回值来替换原始变量的做法没有什么不同—— Python 只是添加了一些语法糖来使之看起来更加明确。

使用装饰器很简单！虽说写类似 staticmethod 或者 classmethod 的实用装饰器比较难，但用起来仅仅需要在函数前添加 @装饰器名 即可！

11. args 和 *kwargs
上面我们写了一个实用的装饰器，但它是硬编码的，只适用于特定类型的函数——带有两个参数的函数。内部函数 checker 接收两个参数，然后继续将参数传给闭包中的函数。如果我们想要一个能适用任何函数的装饰器呢？让我们来实现一个为每次被装饰函数的调用添加一个计数器的装饰器，但不改变被装饰函数。这意味着这个装饰器必须接收它所装饰的任何函数的调用信息，并且在调用这些函数时将传递给该装饰器的任何参数都传递给它们。

碰巧，Python 对这种特性提供了语法支持。请务必阅读 Python Tutorial 以了解更多，但在定义函数时使用 * 的用法意味着任何传递给函数的额外位置参数都是以 * 开头的。如下：

Python

>>> def one(*args):
...     print args # 1
>>> one()
()
>>> one(1, 2, 3)
(1, 2, 3)
>>> def two(x, y, *args): # 2
...     print x, y, args
>>> two('a', 'b', 'c')
a b ('c',)
1
2
3
4
5
6
7
8
9
10
>>> def one(*args):
...     print args # 1
>>> one()
()
>>> one(1, 2, 3)
(1, 2, 3)
>>> def two(x, y, *args): # 2
...     print x, y, args
>>> two('a', 'b', 'c')
a b ('c',)
第一个函数 one 简单的打印了传给它的任何位置参数（如果有）。在 #1 处可以看到，在函数内部只是简单的用到了变量 args —— *args 只在定义函数时用来表示位置参数将会保存在变量 args 中。Python 也允许指定一些变量，并捕获任何在 args 里的额外参数，如 #2 处所示。

* 符号也可以用在函数调用时，在这里它也有类似的意义。在调用函数时，以 * 开头的变量表示该变量内容需被取出用做位置参数。再举例如下：

Python

>>> def add(x, y):
...     return x + y
>>> lst = [1,2]
>>> add(lst[0], lst[1]) # 1
3
>>> add(*lst) # 2
3
1
2
3
4
5
6
7
>>> def add(x, y):
...     return x + y
>>> lst = [1,2]
>>> add(lst[0], lst[1]) # 1
3
>>> add(*lst) # 2
3
在 #1 处的代码和 #2 处的作用相同——可以手动做的事情，在 #2 处 Python 帮我们自动处理了。这看起来不错，*args 可以表示在调用函数时从迭代器中取出位置参数， 也可以表示在定义函数时接收额外的位置参数。

接下来介绍稍微复杂一点的用来表示字典和键值对的 **，就像 * 用来表示迭代器和位置参数。很简单吧？

Python

>>> def foo(**kwargs):
...     print kwargs
>>> foo()
{}
>>> foo(x=1, y=2)
{'y': 2, 'x': 1}
1
2
3
4
5
6
>>> def foo(**kwargs):
...     print kwargs
>>> foo()
{}
>>> foo(x=1, y=2)
{'y': 2, 'x': 1}
当定义一个函数时，使用 **kwargs 来表示所有未捕获的关键字参数将会被存储在字典 kwargs 中。此前 args 和 kwargs 都不是 Python 中语法的一部分，但在函数定义时使用这两个变量名是一种惯例。和 * 的使用一样，可以在函数调用和定义时使用 **。

Python

>>> dct = {'x': 1, 'y': 2}
>>> def bar(x, y):
...     return x + y
>>> bar(**dct)
3
1
2
3
4
5
>>> dct = {'x': 1, 'y': 2}
>>> def bar(x, y):
...     return x + y
>>> bar(**dct)
3
12. 更通用的装饰器
用学到的新知识，可以写一个记录函数参数的装饰器。为简单起见，仅打印到标准输出：

Python

>>> def logger(func):
...     def inner(*args, **kwargs): #1
...         print "Arguments were: %s, %s" % (args, kwargs)
...         return func(*args, **kwargs) #2
...     return inner
1
2
3
4
5
>>> def logger(func):
...     def inner(*args, **kwargs): #1
...         print "Arguments were: %s, %s" % (args, kwargs)
...         return func(*args, **kwargs) #2
...     return inner
注意在 #1 处函数 inner 接收任意数量和任意类型的参数，然后在 #2 处将他们传递给被包装的函数。这样一来我们可以包装或装饰任意函数，而不用管它的签名。

Python

>>> @logger
... def foo1(x, y=1):
...     return x * y
>>> @logger
... def foo2():
...     return 2
>>> foo1(5, 4)
Arguments were: (5, 4), {}
20
>>> foo1(1)
Arguments were: (1,), {}
1
>>> foo2()
Arguments were: (), {}
2
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
>>> @logger
... def foo1(x, y=1):
...     return x * y
>>> @logger
... def foo2():
...     return 2
>>> foo1(5, 4)
Arguments were: (5, 4), {}
20
>>> foo1(1)
Arguments were: (1,), {}
1
>>> foo2()
Arguments were: (), {}
2
每一个函数的调用会有一行日志输出和预期的返回值。

再聊装饰器
如果你一直看到了最后一个实例，祝贺你，你已经理解了装饰器！你可以用新掌握的知识做更多的事了。

你也许考虑需要进一步的学习：Bruce Eckel 有一篇很赞的关于装饰器文章，他使用了对象而非函数来实现了装饰器。你会发现 OOP 代码比纯函数版的可读性更好。Bruce 还有一篇后续文章 providing arguments to decorators，用对象实现装饰器也许比用函数实现更简单。最后，你可以去研究一下内建包装函数 functools，它是一个在装饰器中用来修改替换函数签名的装饰器，使得这些函数更像是被装饰的函数。