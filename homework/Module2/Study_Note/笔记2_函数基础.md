## ** 第一章：函数参数**
#### **一、形参、实参

#### **二、位置参数**
&emsp;&emsp;调用函数时，参数值与参数的位置一一对应。

#### **三、关键字参数**
&emsp;&emsp;调用函数时，指定参数对应的参数值。

#### **四、非固定参数**
##### **语法：**
    def func(self, *args, **kwargs)
如下为参数详解：
* *args：调用函数时，将剩余没有找到的位置参数，都打包成一个元组中导入函数。参数名称不一定要是args，也可以自己定义。如：\*user。但为了规范，请使用\*args
* **kwargs：调用函数时，将没有找到的关键参数，都打包到一个字典中导入函数。参数名称不一定要是kwargs，也可以自己定义。如：\*dict。但为了规范，请使用\*kwargs
##### **代码部分：**
    def func(name, *args, **kwargs):
        print(name, args, kwargs)
    func('henry', 'it', 'hr', address='shanghai', phone='123')
##### **输出内容：**
    henry ('it', 'hr') {'address': 'shanghai', 'phone': '123'}
* 我们可以发现，由于'henry'是name的位置参数，所以被name参数调用。
* 'it', 'hr'由于没有位置参数，被args参数调用，并且封装为一个元组。
* address='shanghai', phone='123'是没有在函数中定义的关键字参数。所以被kwargs参数调用。并封装为一个字典
##### **讲解部分：**
    第一步：定义一个带有name, *args, **kwargs参数的func函数。
    第二步：打印name，args，kwargs
    第三步：调用func函数并给函数中的参数赋值
#### **五、预定字典、列表、元组导入非固定参数**
&emsp;&emsp;有时我们可能已经预先定义好了一个字典、列表、元组。希望导入到函数的args、kwargs中该怎么办？
##### **代码部分：**
    def func(name, *args, **kwargs):
        print(name, args, kwargs)
    list = ['it', 'hr']
    tup = ('it', 'hr')
    dict = {'address': 'shanghai', 'phone': 123}
    func('henry', *list, **dict)
    func('tom',*tup, **dict)
##### **输出内容：**
    henry ('it', 'hr') {'address': 'shanghai', 'phone': 123}
    tom ('it', 'hr') {'address': 'shanghai', 'phone': 123}
##### **讲解部分：**
    只需要在调用函数时，在参数前加一个“*”号，就被args参数调用。加“**”，就被kwargs参数调用

## **第二章：在函数里修改全局变量**
&emsp;&emsp;默认函数中无法修改全局变量的内容。但可以在函数中使用global语句。global语句可以起到声明变量作用域，也可以理解为能修改重新定义全局变量的作用
##### **代码部分：**
    name = 'henry'
    def func():
        global name
        name = 'jenry'
        print('函数中变量:',name)
    func()
    print('全局变量：',name)
##### **输出内容：**
    函数中变量: jenry
    全局变量： jenry
##### **讲解部分：**
    使用gloabl语句后，全局变量就进行了修改。
#### **注意**
&emsp;&emsp;如果全局变量是一个列表、字典、集合、对象哪。里面的内容是否修改。

##### **代码部分：**

    name = ['henry', 'jenry', 'tom']
    def func():
    name[1] = 'mike'
    print('函数中变量:',name)
    func()
    print('全局变量：',name)
##### **输出内容：**

    函数中变量: ['henry', 'mike', 'tom']
    全局变量： ['henry', 'mike', 'tom']
##### **讲解部分：**

    虽然全局变量在一块不能修改的内存区块中，但列表、字典、集合、对象中的内容。却在另外的一块可以修改的内存区块中。所以可以修改。

## **第三章：函数返回值——返回函数**
&emsp;&emsp;有事函数不需要马上执行，而是在后面的代码中，根据需要再计算怎么办？可以不返回结果，而是返回函数：
##### **代码部分：**
    def lazy_sum(*args):
        def sum():
            ax = 0
            for n in args:
                ax = ax + n
            return ax
        return sum
    f = lazy_sum(1,3,5,7,9)
    print(f)
##### **输出内容**
    <function lazy_sum.<locals>.sum at 0x0000021AF305A8C8>

## **第四章：函数作用域**
&emsp;&emsp;一个函数就是一个作用域。函数中的局部变量只在这个作用域有效。代码定义完成后，作用域生成，作用域链向上查找。

## **第五章：匿名函数**
&emsp;&emsp;lambda 函数是一种快速定义单行的最小函数，可以用在任何需要函数的地方。
#### **一、语法**
    lambda [arg1 [,arg2, ... argN]] : expression
等同于：

    def func(arg1[, arg2, ... argN]):
    return expression
使用匿名函数时，如有判断语句。请转换为三元运算。
##### **代码部分：**
    func = lambda x,y: x*y
    print(func(2,4))
##### **代码讲解**
    第一步：定义一个lambda语句。参数是x、y。返回值x*y。并赋值为func变量
    第二步：打印func(2,4)
#### **二、其他**
&emsp;&emsp;匿名函数的作用是什么？它可以和其他方法搭配使用，做到快速的运算。<br>
案例一：<br>
使用map()函数，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：

    >>> map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])
    [1, 4, 9, 16, 25, 36, 49, 64, 81]

案例二：<br>
求1到100的累加.

    reduce(lambda x,y:x + y,xrange(1,101)

## **map()函数讲解**
&emsp;&emsp;map() 会根据提供的函数对指定序列做映射。<br>
第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。<br>
#### **语法**
    map(function, iterable, ...)
相关参数：
* function：函数
* iterable：一个或多个序列
## **reduce()函数讲解**
&emsp;&emsp;reduce() 函数会对参数序列中元素进行累积。<br>
函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给reduce中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。
#### **语法**
    reduce(function, iterable[, initializer])
相关参数：
* function -- 函数，有两个参数
* iterable -- 可迭代对象
* initializer -- 可选，初始参数
#### **注意**
&emsp;&emsp;在Python3中需要import functools

## **高阶函数**
&emsp;&emsp;变量可以指向函数。函数的参数支持一个变量。也可以支持一个函数。那函数支持另一个函数作为参数就是高阶函数。
#### **代码部分：**
    def add(x, y, f):
        return f(x) + f(y)
    print(add(-5, 6, abs))
#### **输出内容：**
    11
## **函数-递归**
&emsp;&emsp;在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。
递归函数特性：
* 必须有一个明确的结束条件；如果没有结束条件，会一直递归导致栈溢出。
* 每次进入更深一层递归时，问题规模相比上次递归都应有所减少。
* 相邻两次重复之间有紧密的联系，前一次要为后一次做准备（通常前一次的输出就作为后一次的输入）。
* 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）。
#### **代码部分：**
我们来计算阶乘n! = 1 x 2 x 3 x ... x n
    def fact(n):
        if n==1: #递归结束条件
            return 1 #触发返回值
        return n * fact(n - 1)
#### **输出内容：**
上面就是一个递归函数。可以试试：

    >>> fact(1)
    1
    >>> fact(5)
    120
    >>> fact(100)
    93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L
#### **讲解部分**
    如果我们计算fact(5)，可以根据函数定义看到计算过程如下：
    ===> fact(5)
    ===> 5 * fact(4)
    ===> 5 * (4 * fact(3))
    ===> 5 * (4 * (3 * fact(2)))
    ===> 5 * (4 * (3 * (2 * fact(1))))
    ===> 5 * (4 * (3 * (2 * 1)))
    ===> 5 * (4 * (3 * 2))
    ===> 5 * (4 * 6)
    ===> 5 * 24
    ===> 120
    从如上的递归过程我们可以初步知道。递归，会先从最外层一步一步的进入到内层。每一层值都会被记录。当触发结束条件时，会触发从内到外层的值计算。并返回最后的结果。
## **内置方法**
0. abs(): 取绝对值
1. dict(): 转换为字典
2. help()：提取帮助
3. min()：取最小值
4. setattr():
5. bool()
6. all():
7. any():
8. dir(): 打印程序里面所有的变量
9. hex(): 转成16进制
10. slice
11. divmod(): 整除
12. id()：打印变量的内存
13. object
14. sorted():序列排序
&emsp;&emsp;sorted() 函数对所有可迭代的对象进行排序操作。
    sort 与 sorted 区别：
    sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。
    list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。
    语法
sorted 语法：
sorted(iterable[, cmp[, key[, reverse]]])
参数说明：
iterable -- 可迭代对象。
cmp -- 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。
key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。
返回值
返回重新排序的列表。
实例
以下实例展示了 sorted 的使用方法：
>>>a = [5,7,6,3,4,1,2]
>>> b = sorted(a)       # 保留原列表
>>> a
[5, 7, 6, 3, 4, 1, 2]
>>> b
[1, 2, 3, 4, 5, 6, 7]

>>> L=[('b',2),('a',1),('c',3),('d',4)]
>>> sorted(L, cmp=lambda x,y:cmp(x[1],y[1]))   # 利用cmp函数
[('a', 1), ('b', 2), ('c', 3), ('d', 4)]
>>> sorted(L, key=lambda x:x[1])               # 利用key
[('a', 1), ('b', 2), ('c', 3), ('d', 4)]


>>> students = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
>>> sorted(students, key=lambda s: s[2])            # 按年龄排序
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(students, key=lambda s: s[2], reverse=True)       # 按降序
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
>>>
15. eval()：将字符串转换为代码。只能转换一行
16. exec(): 将字符串转换为代码。能转换多行。exec拿不到返回值。
17. ord()：打印ascii码ID和字符的对应
18. sum()：求和。
19. filter()：和map语法一直。去除序列中符合lambal条件的内容。
20. reduce()
21. print():
22. callable()：判断是否可以调用
23. vars()：打印所有的变量名和对应的值。
24. locale()：打印函数的局部变量
25. globals()：打印全局变量
26. zip()：将2个列表中的元素用元组的方式一一对应。无法对应的直接丢弃
27. complie()：编译代码
28. reversed()：
29. complex()：变成复数
30. hassttr()：
31. rount()：浮点数保留几位小数
32. hash()：把一个字符串变成hash
33. set():

## **练习**

