# **第一章：面向对象编程与面向过程编程** 
## **1.面向过程编程**
&emsp;&emsp;面向过程的编程，就是将一个大的任务拆分成多个小任务。完成了所有的小任务，也就完成了整个任务
### 优点:
1. 将负责的问题流程化，进而简单化。
2. 运行速度快
### 缺点：
1. 扩展性非常差。当需要增加代码时，就捉襟见肘，需要修改多处。
### 使用方法:
- 适合用于一些简单的自动化，监控脚本中。

## **2.面向对象编程**
我们可能之前听说过“python一起都对象”的说法。
在面向对象编程之前，需要了解什么是对象？
我们可以这样理解，对象是可以对其做事情的一些东西。这个对象有一定的特征和技能，可以处理你要求它做的事情。
### 优点:
1. 可扩展性强。
### 缺点：
1. 编程复杂度高。
### 使用方法:
- 适合用于一些复杂的程序系统，如：游戏、公司的各种管理系统、等。
# **第二章：如何使用面向对象编写程序**
## **1.概述**
首先我们看一下面向对象编程中牵涉到一些概念。
面向对象技术简介
- 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
(打个比方：如Henry，Tom是两个人，无论Henry和Tom他们个体都是是属于一个对象。那么它的类就是——人类。Henry、Tom共有的属性，比如他们有年龄，名字，工作、等。
Henry、Tom共有的方法，比如：说话，吃饭，走路，等)
- 类的属性：类的属性包含两个属性(数据属性、函数属性)：
> - 数据属性：类中定义的变量。类变量概念如下：
>>> - 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
> - 函数属性：类中定义的函数。（函数属性，也可以理解为是实例的方法）
- 实例化：创建一个类的实例，类的具体对象。（打个比方：我们使用人类这个类定义Jerry。那么Jerry就是人类这个类的一个实例化出来的对象）
- 实例变量：定义在类中__init__函数属性中的变量，只作用于当前实例的变量，也是当前实例自己独有的属性。
- 实例：使用类创建的一个个对象，包含类变量、实例变量、和类的函数变量。(打个比方：Jerry就是用人类这个类，
最后生成的实例)。实例还包含两个内容（属性和方法）：
> - 属性：类变量和实例变量都是对象的属性。
> - 方法：类的函数属性就是对象的方法。
- 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。
- 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
- 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。
- 对象：通过类定义的数据结构实例化而得的就是对象。对象包括两个数据成员（类变量和实例变量）和方法。
# ** 第三章：类的使用**
## **1.定义类**
#### ** 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def learn(self):  # 定义类的函数属性
        print('learning')

    def eat(self):
        print('eating')
```


## **2. 使用类——实例化对象**
#### ** 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def learn(self):  # 定义类的函数方法
        print('learning')

    def eat(self):
        print('eating')
        
persion1 = Persion()  # 创建实例化对象persion1
```
使用persion1 = Persion()语句。就使用了Persion类实例化了一个persion1的对象。
## **4. 类的执行过程**
类会在定义阶段就执行内部的代码，并放入名称空间。与函数不同，函数只是在调用时才会执行。
## **5. 调用类的数据属性**
调用类的数据属性方法：
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def learn(self):  # 定义类的函数属性
        print('learning')

    def eat(self):
        print('eating')

stu_star = Persion.star  # 调用类的数据属性
print(stu_star)
```
#### 输出内容：
```text
earth
```
## **6. 增加类的数据属性**
增加类的数据属性方法：
###### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

Persion.country = 'china'  # 增加的数据属性
print(Persion.__dict__)
```
###### 输出内容：
```text
{'__module__': '__main__', 'star': 'earth', 'learn': <function Persion.learn at 0x7f8b36d1a158>, 'eat': <function Persion.eat at 0x7f8b36d1a1e0>,
 '__dict__': <attribute '__dict__' of 'Persion' objects>, '__weakref__': <attribute '__weakref__' of 'Persion' objects>, '__doc__': None, 'country': 'china'}
```
## **7.删除类的数据属性**
删除类的数据属性方法：
#### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

del Persion.star  # 删除类的数据属性
print(Persion.__dict__)
```
#### 输出内容：
```text
{'__module__': '__main__', 'learn': <function Persion.learn at 0x7f0c21f17158>, 'eat': <function Persion.eat at 0x7f0c21f171e0>, '__dict__': <attribute '__dict__' of 'Persion' objects>, 
'__weakref__': <attribute '__weakref__' of 'Persion' objects>, '__doc__': None}
```

## ** 8.修改类的数据属性**
修改类的属性方法如下：
#### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

Persion.star = 'mars'  # 修改类的数据属性
print(Persion.__dict__)
```
#### 输出内容：
```text
{'__module__': '__main__', 'star': 'mars', 'learn': <function Persion.learn at 0x7ff494004158>, 'eat': <function Persion.eat at 0x7ff4940041e0>, 
'__dict__': <attribute '__dict__' of 'Persion' objects>, '__weakref__': <attribute '__weakref__' of 'Persion' objects>, '__doc__': None}
```
## ** 9. 类的特殊属性**
类中除了数据属性和函数属性，还有一些自己的特殊属性。
```text
C.__name__：类的名字（字符串）
C.__doc__：类的文档字符串
C.__bases__：类的所有父类构成的元组
C.__dict__：类的所有属性
C.__module__：类定义所在的模块
C.__class__：实例所对应的类
```

# **第四章：对象的使用**
## ** 1. 构造函数——__init__()**
我们先看一下如下的代码
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

persion1 = Persion()
```
我们定义了一个人类的类，创建了一个star的数据属性和2个learn、eat的函数属性（方法）。
并实例化了第一个人类的对象persion1。但是这时，可能你会发现Persion1这个对象，
并不止有star这个属性，他还有name、age、sex等属性。那我们应该怎么在类中定义一些可变的属性呢？这里引出__init__函数属性。
由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。
通过定义一个特殊的__init__方法，在创建实例的时候，就把可变的属性绑上去。修改代码如下：
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
print(persion1.__dict__)
persion2 = Persion('Tom',20, 'man')  # 创建类的实例对象“TOM”
print(persion2.__dict__)
```
#### 输出内容：
```text
{'name': 'Jerry', 'age': 28, 'sex': 'man'}
{'name': 'Tom', 'age': 20, 'sex': 'man'}
```
我们可以看到，这时在创建类的实例对象时。需要向类导入四个实例变量。“self, name, age, sex”。
通过创建实例时，实例变量的导入。就可以为不同的实例创建不同的属性了。
## ** 2.self概念**
大家看到如上代码中类的函数属性的形参都会自动加上一个“self”产生疑问。这个self是什么？<br>
- self：是个对象（Object），是当前类的实例自己。

因此，对应的self.name = name这段代码含义。就是为实例persion1创建一个name变量，
并且使用创建实例时倒入的name变量就行赋值。（可查阅上面章节的“调用类的数据属性”）
## ** 3.实例化过程**
我们具体来讲一下如上代码的实例化过程：
1. 首先persion1实例会像内存申请一个空的内存空间，命名为persion1。
2. 其次persion1实例将自己的命名空间和其他需要传导的实例属性传递给Persion类。
3. 类中的__init__(self, name, age, sex)构建函数，
获取persion1实例的名字空间（self）和其他参数（name, age, sex），进行函数内部的处理。
4. self.name = name在persion1实例的名字空间中创建一个新的name变量，并用传导进入的实参进行赋值
5. 将处理后的结果返回给persion1的名称空间

## ** 4.调用实例的实例属性**
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
print('Name: %s' % persion1.name)  # 打印实例属性

```
#### 输出内容：
```text
Name: Jerry
Star: earth
```
## ** 5.增加实例的实例属性**
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion1.phone = '12345678910'  # 添加实例属性
print('Phone: %s' % persion1.phone)  # 打印增加的属性
```
#### 输出内容：
```text
Phone: 12345678910
```
## ** 6.删除实例的实例属性**
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion1.phone = '12345678910'  # 添加实例属性
print('Phone: %s' % persion1.phone)  # 打印增加的属性
del persion1.phone  # 删除phone实例属性
print('Phone: %s' % persion1.phone)  # 再次打印报错
```
#### 输出内容：
```text
Phone: 12345678910
Traceback (most recent call last):
  File "/development/homework/test.py", line 19, in <module>
    print('Phone: %s' % persion1.phone)  # 再次打印报错
AttributeError: 'Persion' object has no attribute 'phone'
```
## ** 7.修改实例的实例属性**
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion1.age = 48  # 修改age的实例属性
print('Age: %s' % persion1.age)  # 打印修改后的age
```
#### 输出内容：
```text
Age: 48
```
# **第五章：实例属性的调用与绑定方法**
## **1直接调用类是否可行？**
在开始讲实例调用类属性方法之前。现有一个问题，那就是python是否直接可以去调用类中的数据属性和函数属性。当然是可以的？
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性

    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        return ('%s is learning %s' % (self, lesson))

    def eat(self):
        return ('%s is eating' % self.name)

print('并非使用实例调用类的数据属性Star：%s' % Persion.star)
print('并非使用实例调用类的函数属性Learn：%s' % Persion.learn('test','python'))
```
#### 输出内容：
```text
并非使用实例调用类的数据属性Star：earth
并非使用实例调用类的函数属性Learn：test is learning python
```
这种方式并没有创建实例，而只是获取了Persion类中的star变量的值和执行learn函数而已。我们甚至可以看到类中learn函数的self参数也不在代表实例自己，
而是简单的一个形参而已这是由于类是在程序启动时就编译好的，所以可以直接使用Persion.star语法将star数据属性读出来。<br>
大家可能会问，这种写法有什么意义吗？好像和面向对象开发没有任何的关系。其实有一种和实例配合场景，会使用到这种技巧。比如，我有一个网页的注册接口，
使用类的方式写的，每次一个用户注册，都会起一个实例去进行数据库读写的操作。但当访问量大时，可能会导致注册接口遇到瓶颈。我需要增加一个计数器，
要求，当一共有10个实例创建时。暂停注册，将后续注册的数据缓存一下。如下用代码举例：<br>
如：全局计数器功能，每当没创建一个实例时，计数器增加1。并且这个计数器的数据所有实例，和类自己都能查看。
#### 代码部分：
```python
class Persion:
    star = 'earth'
    count = 0  # 定义一个类的数据属性。同时它也是Persion类的一个全局变量。
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex
        Persion.count += 1  # 每当有__init__函数被执行时，就将Persion类的count变量+1

    def learn(self, lesson):  # 定义类的函数函数
        return ('%s is learning %s' % (self, lesson))

    def eat(self):
        return ('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.learn('Python')  # 调用实例的方法，并付给learn函数一个lesson变量
persion2.learn('Java')  # 调用实例的方法，并付给learn函数一个lesson变量
print('%s count: %s' % (persion1.name, persion1.count))
print('%s count: %s' % (persion2.name, persion2.count))
print('Class count: %s' % Persion.count)
```
#### 输出内容：
```text
Jerry count: 2
Tom count: 2
Class count: 2
```
我们可以看到这时，打印出来的计数器的值都为2。
## **2. 实例调用类的数据属性**
上一章节，我们为实例创建了独有的实例属性。但类中的数据函数属性我们并没有在实例中发现。那类的数据属性是否在实例中哪？
答案肯定是的。
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print('%s star: %s ' % (persion1.name, persion1.star))  # 打印persion1实例的属性
print('%s star: %s' % (persion2.name, persion2.star))  # 打印persion实例的属性
print('Class star: %s' % Persion.star)  # 答应Persion类的属性
# 打印persion1、persion2实例和Persion类中star属性的id。看内存地址是否不一样
print('%s id(star): %s ' % (persion1.name, id(persion1.star)))  # 打印persion1实例的属性
print('%s id(star): %s' % (persion2.name, id(persion2.star)))  # 打印persion实例的属性
print('Class id(star): %s' % id(Persion.star))  # 答应Persion类的属性
```
#### 输出内容：
```text
Jerry star: earth 
Tom star: earth
Class star: earth
Jerry id(star): 140636602176208 
Tom id(star): 140636602176208
Class id(star): 140636602176208
```
我们可以从输出看到类中star数据属性的变量。每个实例都能调用。并且内存空间都是一样的。
## **3. 实例修改类的数据属性**
有了调用当然可以修改。但大家想一下如果修改了类的数据属性，会发生什么？
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.star = 'mars'  # 修改persion1实例的star属性为mars
print('%s star: %s ' % (persion1.name, persion1.star))  # 打印persion1实例的属性
print('%s star: %s' % (persion2.name, persion2.star))  # 打印persion实例的属性
print('Class star: %s' % Persion.star)  # 答应Persion类的属性
# 打印persion1、persion2实例和Persion类中star属性的id。看内存地址是否不一样
print('%s id(star): %s ' % (persion1.name, id(persion1.star)))  # 打印persion1实例的属性
print('%s id(star): %s' % (persion2.name, id(persion2.star)))  # 打印persion实例的属性
print('Class id(star): %s' % id(Persion.star))  # 答应Persion类的属性
```
#### 输出内容：
```text
Jerry star: mars 
Tom star: earth
Class star: earth
Jerry id(star): 140526009104680 
Tom id(star): 140526009103056
Class id(star): 140526009103056
```
我们可以发现，就只有persion1实例自己讲stars属性修改为了“mars”，并且内存空间也进行了修改。<br>
这说明实例并不能直接修改类的数据属性。但会重新为这个实例分配一个新的命名空间。
## **4. 实例与函数属性的关系——绑定方法**
类的函数属性是绑定给实例的。不同的实例所绑定的函数属性的名称空间地址不同。
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print('Class NameSpace: %s' % Persion.learn)  # 打印类的learn函数属性的名称空间
print('%s NameSpace: %s' % (persion1.name, persion1.learn))  # 打印persion1实例的learn函数属性的名称空间
print('%s NameSpace: %s' % (persion2.name, persion2.learn))  # 打印persion2实例的learn函数属性的名称空间
```
#### 输出内容：
```text
Class NameSpace: <function Persion.learn at 0x7f6eee555268>
Jerry NameSpace: <bound method Persion.learn of <__main__.Persion object at 0x7f6eee5629b0>>
Tom NameSpace: <bound method Persion.learn of <__main__.Persion object at 0x7f6eee5629e8>>
```
我们可以看到，类和实例的命名空间完全的不同。并且实例的输出了
“<bound method Persion.learn of <__main__.Persion object at 0x7f6eee5629b0>>"
表明自己的内存空间是绑定到Persion类的learn函数属性。
## **5.实例调用类的函数属性**
哪实例如何调用类的函数属性？
#### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('%s is learning' % self.name)

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.learn()  # 调用实例的方法
persion2.learn()  # 调用实例的方法
```
#### 输出部分：
```text
Jerry is learning
Tom is learning
```
我们只要使用persion1.learn()的方式就可以调用类的函数属性。并创建实例的方法。也就是将persion1这个实例的内存空间作为learn函数的self变量，
传递到learn函数中。

## **6.实例调用带参数的类函数属性**
哪如果类中learn函数带有其他自己独有的参数呢？
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        print('%s is learning "%s"' % (self.name, lesson))

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.learn('Python')  # 调用实例的方法，并付给learn函数一个lesson变量
persion2.learn('Java')  # 调用实例的方法，并付给learn函数一个lesson变量
```
#### 输出内容
```text
Jerry is learning "Python"
Tom is learning "Java"
```
我们可以看到，通过使用persion1.learn('Python')方法就可以将learn函数中独有的变量传导进去。
# ** 第六章：实例属性的查找顺序
## ** 1. 属性的操作顺序
我们在如上章节讲了类的属性，创建实例和使用实例的属性和方法。那现在我们来看一下，实例查找属性的先后顺序。
##### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        print('%s is learning "%s"' % (self.name, lesson))

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print(persion1.__dict__)  # 实例自己的属性
print(persion2.__dict__)  # 实例自己的属性
```
#### 输出部分：
```text
{'name': 'Jerry', 'age': 28, 'sex': 'man'}
{'name': 'Tom', 'age': 28, 'sex': 'man'}
```
我们首先可以看到实例有自己的独有属性。这些属性怎么来的哪？是类中定义的__init__函数给传递进去的。所以当类没有__init__函数时，
实例默认也没有任何属性。<br>
那么大家可能有个问题。不是之前可以使用persion1.star()调用类的数据属性,不是使用persion1.learn()调用类的函数属性吗？
是的，但是这些属性。并没有存在实例的名称空间中。而是实例向自己的类进行查找而获得来的。如：<br>
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        print('%s is learning "%s"' % (self.name, lesson))

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print(persion1.__dict__)  # 实例自己的属性
print(persion2.__dict__)  # 实例自己的属性
print(persion1.star)  # 实例到自己的类中进行查找，找到了star属性
print(persion2.star)  # 实例到自己的类中进行查找，找到了star属性
```
#### 输出内容：
```text
{'name': 'Jerry', 'age': 28, 'sex': 'man'}
{'name': 'Tom', 'age': 28, 'sex': 'man'}
earth
earth
```
如何去理解哪。实例首先在自己的名字空间中炒作star属性。发现没有？然后定位到自己的类是Persion，然后查找类的名字空间，发现了star属性。
最后将这个star属性直接调用出来。
## ** 2.总结**
1. 首先创建实例时，如果类中有__init__函数就会创建实例自己的属性。当调用实例属性时，如发现实例属性中已有。先调用实例属性。
2. 如果实例属性中没有。就向自己的类中进行查找。类中有的话，就调用类的属性。
3. 如果类也没有，报错退出。

# **第七章：对象之间的交互**
如上章节我们都是创建了不同的实例，但是实例与实例之间并没有任何的交互。本章我们来讲解一下实例之间的交互。<br>
引出一个例子：中美两个公司的之间相互转账。
#### 代码部分：
```python
class Baidu:  # 创建了一个Baidu类
    company = 'BAIDU'  # 创建了一个数据属性，百度
    def __init__(self,card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount


    def transaction(self, another):  # 类的函数，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款

class Ibm:  # 同样创建一个Ibm类
    company = 'IBM'  # 创建了一个数据属性，百度
    def __init__(self, card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount

    def transaction(self, another):  # 类的函数属性，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款


baidu = Baidu('123456', 23, 10)  # 使用中国类创建一个百度的实例
ibm = Ibm('654321', 13, 10)  # 使用美国类创建一个ibm的实例
baidu.transaction(ibm)  # 百度转账给ibm
print('BAIDU card [%s] persent balance: %s'% (baidu.card,baidu.balance))  # 答应百度的当前银行卡余额
print('IBM card [%s] persent balance: %s'% (ibm.card,ibm.balance))  # 答应ibm的当前银行卡余额
```
#### 输出结果：
```text
BAIDU card [123456] persent balance: 13
IBM card [654321] persent balance: 23
```
我们看到通过在类的 def transaction(self, another)函数属性中增加一个形参（another），它的实参就是另一个实例。
这种方式就实现的实例之间的交互，一个实例触发的方法会对其他实例产生联动性
# **第八章：补充知识**
1. 站的角度不同，定义出的类截然不同
2. 现实中的类并不一定等于程序中的类，比如现实中的公司类，现实拆分为业务、部门类
3. 有时编程需要，程序可以定义现实中不存在的类。如：策略类。


# ** 第九章： 继承**
继承指的是类与类之间的关系，在python中，新建的类可以继承一个或多个父类，父类也可以称为基类或超类
，新建的类称为派生类或子类。子类与父类之间是is的关系，父类有的属性和方法，子类中也都可以使用。
继承的功能之一用来解决代码的重用性。
## ** 1.继承的语法**
```python
class ParentClass1:  # 父类
    pass

class ParentClass2:  # 父类
    pass

class SubClass1(ParentClass1):  # 子类继承ParentClass1父类
    pass

class SubClass2(ParentClass1,ParentClass2):  # 子类继承ParentClass1,ParentClass2父类
    pass
```
## **2. 查询类的继承关系**
我们如何去查找某个类是否有自己的继承关系哪？
###### 代码部分：
```python
class ParentClass1:  # 父类
    pass

class ParentClass2:  # 父类
    pass

class SubClass1(ParentClass1):  # 子类继承ParentClass1父类
    pass

class SubClass2(ParentClass1,ParentClass2):  # 子类继承ParentClass1,ParentClass2父类
    pass

print(SubClass1.__bases__)  # 查看SubClass1类的父类
print(SubClass2.__bases__)  # 查看SubClass2类的父类
```
###### 输出部分：
```text
(<class '__main__.ParentClass1'>,)
(<class '__main__.ParentClass1'>, <class '__main__.ParentClass2'>)
```

#### ** 3. 子类与父类的关系
我们之前提到了子类和父类是is的关系。怎么去理解这句话，我们用“对象之间的交互”章节中的代码来讲解一下：
```python
class Baidu:  # 创建了一个Baidu类
    company = 'BAIDU'  # 创建了一个数据属性，百度
    def __init__(self,card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount


    def transaction(self, another):  # 类的函数，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款

class Ibm:  # 同样创建一个Ibm类
    company = 'IBM'  # 创建了一个数据属性，百度
    def __init__(self, card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount

    def transaction(self, another):  # 类的函数属性，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款


baidu = Baidu('123456', 23, 10)  # 使用中国类创建一个百度的实例
ibm = Ibm('654321', 13, 10)  # 使用美国类创建一个ibm的实例
baidu.transaction(ibm)  # 百度转账给ibm
print('BAIDU card [%s] persent balance: %s'% (baidu.card,baidu.balance))  # 答应百度的当前银行卡余额
print('IBM card [%s] persent balance: %s'% (ibm.card,ibm.balance))  # 答应ibm的当前银行卡余额
```
如上的代码，我们创建了2个公司的类，一个是Baidu，另一个是Ibm。那么他们是否可以有一个父类。当然可以！我们定义一个Company的类，
那么这个Company的类也有自己的构建函数和transaction的函数属性哪？必然是可以的。修改代码如下：
###### 代码部分：
```python
class Company:  # 父类
    def __init__(self,card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount


    def transaction(self, another):  # 类的函数，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款


class Baidu(Company):  # Baidu类继承Company父类
    name = 'BAIDU'  # 创建了一个数据属性，百度


class Ibm(Company):  # Ibm类继承Company父类
    name = 'IBM'  # 创建了一个数据属性，百度



baidu = Baidu('123456', 23, 10)  # 使用中国类创建一个百度的实例
ibm = Ibm('654321', 13, 10)  # 使用美国类创建一个ibm的实例
baidu.transaction(ibm)  # 百度转账给ibm
print('BAIDU card [%s] persent balance: %s'% (baidu.card,baidu.balance))  # 打印百度的当前银行卡余额
print('IBM card [%s] persent balance: %s'% (ibm.card,ibm.balance))  # 打印ibm的当前银行卡余额
```
###### 输出部分：
```text
BAIDU card [123456] persent balance: 13
IBM card [654321] persent balance: 23
```
我们可以发现Baidu、IBM类并没有定义构建函数和函数属性。但是程序还是照样运行正常。这就说明了，父类中定义的所有东西，如果子类中没有定义相同的内容的化。子类就会默认调用父类中的所有的属性。

#### **4.继承中实例属性的查找先后顺序
我们知道普通类中，实例属性的查找先后顺序如下：
1. 首先创建实例时，如果类中有__init__函数就会创建实例自己的属性。当调用实例属性时，如发现实例属性中已有。先调用实例属性。
2. 如果实例属性中没有。就向自己的类中进行查找。类中有的话，就调用类的属性。
3. 如果类也没有，报错退出。
但在继承类中哪？查找顺序如下：
1. 首先创建实例时，会在自己类中查找是否有__init__函数。有的话，就会创建实例自己的属性，但是如果自己类中没有__init__函数，就会从自己的父类中取查找__init__函数，
如果父类有的话，就继承父类的__init__函数，创建实例自己的属性。当父类也没有的话，实例就不带任何属性。
2. 如果实例属性中没有。就向自己的类中进行查找。类中有的话，就调用类的属性。如果自己类中没有，就向父类中查找，类中有的话，就调用父类的属性
3. 如果父类也没有，报错退出。
但是我们看一下如下这个代码：
##### 代码部分：
```python
class Company:  # 父类
    def transaction(self):  # 类的函数，转账
        print("Transaction monry to your Comany")
        self.purchase()  # 调用实例的采购函数。等于：badiu.purchase


    def purchase(self):  # 类的函数，采购
        print("Your Comany can purchase something.")


class Baidu(Company):  # Baidu类继承Company父类
    def purchase(self):  # 派生一个自己的采购函数
        print("My Comany can purchase Phone.")

baidu = Baidu()  # 使用中国类创建一个百度的实例
baidu.transaction()
```
###### 输出内容：
```text
Transaction monry to your Comany
My Comany can purchase Phone.
```
我们来看一下输出的内容。
- 第一行的“Transaction monry to your Comany”很好理解。当实例调用transcation时，它去查找自己的属性。
发现自己的实例属性中并没有transcation这个属性，所以到Baidu类中取查找，也发现没有。就到父类company中去查找，找到后就打印出结果（这就是类的继承）。
- 然后发现父类company在transcation属性中还有一段self.purchase()代码。程序会将自己的实例baidu作为self的实参传递给transcation属性。所以self.purchase()代码就等同于
baidu.purchase()。这时baidu实例又触发了一次查找动作。先从自己的实例中查找属性，没有找到。然后在自己的baidu类中查找到了purchase属性。
最后打印出“My Comany can purchase Phone”，而非父类company的“Your Comany can purchase something.”


# ** 第十章：派生**
派生就是子类在继承父类的基础上衍生出新的属性。子类中独有的，父类中没有的；或子类定义与父类重名的东西。子类也叫派生类。
###### 代码部分：
```python
class Company:  # 父类
    name = 'Company' # 父类的name数据属性
    def transaction(self):  # 类的函数属性，转账
        print("Transaction monry to your Comany")
        self.purchase()  # 调用实例的采购函数


    def purchase(self):  # 类的函数属性，采购
        print("Your Comany can purchase something.")


class Baidu(Company):  # Baidu类继承Company父类
    name = 'Baidu'  # 派生一个自己的数据属性
    def purchase(self):  # 派生一个自己的采购函数属性
        print("My Comany can purchase Phone.")

    def website(self):  # 派生一个自己专用的website函数属性。父中没有
        print("www.badiu.com")
```
# ** 第十一章：继承实现原理 **
#### ** 1. 继承的查找原则
python对于定义的每一个类，都会计算出一个方法解析顺序（MPO）列表，这个MPO列表就是一个简单的所有积累的线性顺序列表，
使用mro属性可以查看这个列表：
```text
>>>> Baidu.mro()  # 等同于Baidu.__mro__
[<class '__main__.Baidu'>, <class '__main__.Company'>, <class 'object'>]
```
为了实现继承python会在MRO列表上从左到右查找基类，直到找到第一个匹配的属性为止，而这个MRO列表的构造是通过一个C3线性化
算法来实现的。我们不去深究这个算法的原理，它实际上是合并所有父类的MRO列表并遵循如下原则：
1. 子类会先于父类查找。
2. 多个父类会根据他们在列表中的顺序被查找。
3. 如果有多个类存在相同的属性，使用第一个属性。
#### ** 2. 继承的查询类型——深度优先、广度优先
上面的讲了一个类的查询原则，是依据MRO列表从左到右查找自己的父类。但程序中的类与类之间存在了多种继承的关系，
也就是说，一个父类也可能是其他父类的一个子类。那么一个python中如何最终定位到父类哪？在将这个问题前，我们先引出
python中对类的两个分类的定义与他们的查找方式：<br>
1. 经典类：没有继承object的类，以及他的子类称为经典类，只有在python2中有这个概念。经典类以深度优先的方式查询。语法如下：
> 经典类的语法：
> ```python
> class Foo:
>     pass
> class Bar(Foo):
>     pass
> ```
2. 新式类：继承object的类，以及他的子类称为经典类。python3中所有类都是新式类。新式类以广度优先的方式查询。语法如下：
> 新式类的语法：
> ```python
> class Foo:
>     pass
> class Bar(Foo):
>     pass
> ```
#### ** 3.深度优先查找与广度优先查找的区别
经典类继承查找的先后顺序按照深度优先的方式查找。如何去理解。请看下图：
![深度优先查询](https://github.com/henryyuan/first-app/blob/master/homework/Module3/Study_Note/%E7%BB%A7%E6%89%BF%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%9F%A5%E8%AF%A2.png)
新式类继承查找的先后顺序按照广度优先的方式查找如何去理解。请看下图：
![广度优先查询](https://github.com/henryyuan/first-app/blob/master/homework/Module3/Study_Note/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%9F%A5%E8%AF%A2.png)
深度优先查询规则：
1. A类查询自己的第一个父类B。跳转给B类。
2. B类发现自己并没有A需要的属性，但发现自己有一个父类E。跳转给E类。
3. E类发现自己并没有A需要的属性，但发现自己有一个父类G。跳转给G类。
4. G类有A类需要的属性，返回给A。结束查找。
广度优先查询规则：
1. A类查询自己中的第一个父类B。跳转给B类。
2. B类发现自己并没有A需要的属性，但发现自己有一个父类E。跳转给B类。
3. E类发现自己并没有A需要的属性，但发现自己有一个父类G。
4. 跳过G类，继续查找C类。
5. C类发现自己并没有A需要的属性，但自己有一个父类F。跳转给F类。
6. F类发现自己并没有A需要的属性，然自己有一个父类G。
7. 跳过G类，继续查找D类。
8. D类发现自己并没有A需要的属性，但自己有个父类G类。并且发现自己已经是A类的最后一个父类。跳转给G
9. G发现自己有A需要的属性，返回给A。结束查询。

#### 4.新式类的mro方法
mro的作用就是查询类的MRO列表。
我们模拟一下上面中新式类的例子来看一下mro方法的用法。
###### 代码部分：
```python
class G(object):
    def show(self):
        print("I am G")

class F(G):
    def show(self):
        print("I am F")

class E(G):
    def show(self):
        print("I am E")

class D(G):
    def show(self):
        print("I am D")

class C(F):
    def show(self):
        print("I am C")

class B(E):
    def show(self):
        print("I am B")

class A(B, C ,D):
    pass

print(A.mro())
```
###### 输出部分：
```text
[<class '__main__.A'>, <class '__main__.B'>, <class '__main__.E'>, <class '__main__.C'>, <class '__main__.F'>, <class '__main__.D'>, <class '__main__.G'>, <class 'object'>]
```
可以看到A类的查询顺序完全符合广度优先的规则A-B-E-C-F-D-G的顺序。

# 多态和多态性
## 1. 多态的概念
多态指的是一个类事物有多种形态。比如：
- 动物有多种形态：人、狗、猫、等
- 文件有多种形态：文本文件、可执行文件、等
如下代码就是一个以多态概念编写的代码。
```python
import abc


class Animal(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def talk(self):
        pass
    
    
class Persion(Animal):  # Animal的一种形态
    def talk(self):
        print('I am man')
        

class Dog(Animal):  # Animal的一种形态
    def talk(self):
        print('wangwang')

        
class Cat(Animal):  # Animal的一种形态
    def talk(self):
        print('miaomiao')
```

## 2. 多态性的概念
动态性又称为多态动态绑定（需要在继承的背景下使用）。
多态性指的是可以在不考虑对象的类型的情况下而直接使用对象。更通俗的来说，
在调用方式不变的情况下，可以返回多种不同的执行效果。
如何去理解这句话哪？使用如下代码讲解
```python
import abc


class Animal(metaclass=abc.ABCMeta):  # Animal抽象类
    @abc.abstractmethod
    def talk(self):  # 定义talk方法规范
        pass


class Persion(Animal):  # Animal的一个形态
    def talk(self):  # Persion的talk方法
        print('I am man')


class Dog(Animal):  # Animal的一个形态
    def talk(self):  # Dog的talk方法
        print('wangwang')


class Cat(Animal):  # Animal的一个形态
    def talk(self):  # Cat的talk方法
        print('miaomiao')
# 可以看到Animal类中的有多个形态的类。并且这些形态的talk方法的执行后会得到不同的结果。
# 多态性依赖于继承和抽象类（抽象类的作用是定义更好的接口规范）

# 多态性：通过使用一个函数，多种形态的实例进行统一，让不同的对象都可以执行相同的方法，返回不同的结果
def func(animal):  # animal形参的实参Animal形态的实例。
    animal.talk()  # 所有实例执行相同的talk方法

per1 = Persion()
dog1 = Dog()
cat1 = Cat()

func(per1)
func(dog1)

```
如上代码的开始部分如下：
```python
import abc


class Animal(metaclass=abc.ABCMeta):  # Animal抽象类
    @abc.abstractmethod
    def talk(self):  # 定义talk方法规范
        pass


class Persion(Animal):  # Animal的一个形态
    def talk(self):  # Persion的talk方法
        print('I am man')


class Dog(Animal):  # Animal的一个形态
    def talk(self):  # Dog的talk方法
        print('wangwang')


class Cat(Animal):  # Animal的一个形态
    def talk(self):  # Cat的talk方法
        print('miaomiao')
```
只是定义了一个Animal类的多态。然而后续的代码就反应了多态性。如下：
```python
# 多态性：通过使用一个函数，多种形态的实例进行统一，让不同的对象都可以执行相同的方法，返回不同的结果
def func(animal):  # animal形参的实参Animal形态的实例。
    animal.talk()  # 所有实例执行相同的talk方法

per1 = Persion()
dog1 = Dog()
cat1 = Cat()

func(per1)
func(dog1)
```
无论Animal类中的其他形态，创建了任何实例。都可以只用一种方法talk去执行，并返回不同的结果。
并且通过定义一个func(animal)函数的方式，创建出一个新的接口。这个接口，更加的规范了不同对象调用自己的talk方法。
所以多态性，就是将不同形态的方法进行统一（方法名称使用相同名称）。并通过使用一个新的接口(func函数)的方法，将这些方法进行整合。最后所有的实例，都只是这个接口的参数。
达到在调用方式不变的情况下，可以返回多种不同的执行效果的目的。
## 3. 静态多态性和动态多态性
静态多态性：如任何类型都可以使用+进行运算
动态多态性：就是如上代码。

## 4. 多态性的优点
1. 增加了程序的灵活性：无论对象发生了发生了什么变化，使用者都是用同一种形态去调用。
2. 增加了程序的可扩展性：在类中增加一个新的形态，使用者也无需修改自己的代码。我们可以随意的在上面的代码中增加一个pig类，但使用者的调用方式并不需要改变。

## 5.鸭子类型



    ‘ 那只东西呱呱的叫，有扁扁的嘴巴，走起路来还外八，对！它就是只鸭子’


首先Python不需要支持多态。因为python就是一种支持多态的语言（动态语言）。而鸭子类型是动态语言里面的一种概念。
在程序设计中，鸭子类型（英语：duck typing）是动态语言的一种风格。在这种风格中，
一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定
也就是说，在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭的对象，并调用它的走和叫方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。
python中的具体实现
下面的代码就是一个简单的鸭子类型
```python
class duck():
    def walk(self):
        print('I walk like a duck')
    def swim(self):
        print('i swim like a duck')

class person():
    def walk(self):
        print('this one walk like a duck') 
    def swim(self):
        print('this man swim like a duck')
```
如上代码，可以发现有两个类duck和person虽然它们是不同的类。但又相同的方法。
对于一个鸭子类型来说，我们并不关心这个对象的类型本身或是这个类继承，而是这个类是如何被使用的。

我们可以通过下面的代码来调用这些类的方法。
```python
def watch_duck(animal):
    animal.walk()
    animal.swim()

small_duck = duck()
watch_duck(small_duck)

output >> 
I walk like a duck
i swim like a duck


duck_like_man = person()
watch_duck(duck_like_man)

output >> 
this one walk like a duck
this man swim like a duck


class Lame_Foot_Duck():
    def swim(self):
        print('i am lame but i can swim')

lame_duck = Lame_Foot_Duck()
watch_duck(lame_duck)

output >>
AttributeError: Lame_Foot_Duck instance has no attribute 'walk'
```
可以从如上代码看出，基于鸭子类型设计的程序，对象完全不在乎它是属于persion还是duck类型，只要有相同的方法，就执行代码
watch_duck函数接收这个类的对象，然后并没有检查对象的类型，而是直接调用这个对象的走和游的方法，如果所需要的方法不存在就报错。

# **封装**
封装（Encapsulation）是对具体对象的一种抽象，即是将某些部分隐藏起来。但封装并不完全等于隐藏，
通过封装，类外部无法调用该类的属性和方法，其含义就是使得其他类无法调用这些已经封装的属性和方法。
要了解封装，离不开“私有化”，就是将类或者是函数中的某些属性限制在某个区域之内，外部无法调用。
# **封装的语法**
在python中用双下划线开头的方式将属性和方法隐藏起来。
封装类的数据属性：
```python
class A:
    __N = 0  # 将类的数据属性封装
```
封装类的函数属性：
```python
class A:
    def __foo(self):
        pass
```
封装实例的属性：
```python
class A:
    def __init__(self,name):
        self.__name = name
```
# **封装的实现原理**
封装的目的就是让类中的一些属性和方法，无法被类的外部直接调用。哪python如何实现封装？
其实，封装仅仅是在类定义阶段。将类中所有双下划线开头的名称如__x都会自动变形成：_类名__x的形式。使用如下代码解析封装的实现原理。
#### 代码部分
```python
class A:
    __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N
    def __init__(self, name):
        self.__name = name #变形为self._name__X
    def __foo(self): #变形为_A__foo
        print('from A')


print('类A属性：%s ' % A.__dict__)
a = A('henry')
print('实例a属性：%s' % a.__dict__)
print('访问类的封装属性：%s', A._A__N)
print('访问实例的封装属性：%s', a._A__name)
```
#### 输出部分
```text
类A属性：{'__module__': '__main__', '_A__N': 0, '__init__': <function A.__init__ at 0x7fc30538e158>, '_A__foo': <function A.__foo at 0x7fc30538e1e0>, '__dict__': <attribute '__dict__' of 'A' objects>, '__weakref__': <attribute '__weakref__' of 'A' objects>, '__doc__': None} 
实例a属性：{'_A__name': 'henry'}
访问类的封装属性：%s 0
访问实例的封装属性：%s henry
```
可以从类和实例的命名空间中看到。所有以双下划线开头的属性名称。都在类的定义阶段，装换成了“_所在类名__属性”名称。起到了隐藏的作用。
但是，这种属性名称的变形，可以再类的外部通过“类名._类名__属性”的语句直接访问到的类中的封装属性、可以通过“实例._类名__属性”的方式访问到实例的封装属性和方法。所以这种操作并不是严格意义上的限制外部访问，仅仅只是一种语法意义上的变形。
但实际上，直接去访问变形后的属性名称也是不合理的。
# **封装的特性**
封装有如下三个特性：
- 类的外部，无法直接使用obj.__AttrName的方式访问
#### 代码部分
```python
class A:
    __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N
    def __init__(self, name):
        self.__name = name #变形为self._name__X
    def __foo(self): #变形为_A__foo
        print('from A')


a = A('henry')
print('访问类的封装属性：%s', A.__N)
```
#### 输出部分
```text
Traceback (most recent call last):
  File "/development/homework/test.py", line 10, in <module>
    print('访问类的封装属性：%s', A.__N)
AttributeError: type object 'A' has no attribute '__N'
```
可以看到，如果直接使用“类名.__属性”或者“实例名.__属性”的方式，是无法访问已经封装的属性的。python直接会报出未找到属性的错误。
其实根本的原因就是“类名.__属性”和“实例名.__属性”，被修改为了“类名._类名__属性”和“实例名._类名__属性”。
- 类的内部，可以使用obj.__AttrName的方法访问。
#### 代码部分
```python
class A:
    __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N
    def __init__(self, name):
        self.__name = name #变形为self._A__X

    def __foo(self): #变形为_A__foo
        print('from A')

    def bar(self):
        self.__foo() #只有在类内部才可以通过__foo的形式访问到。其实原理也是在类定义时，变形成self._A__foo

a = A('henry')
a.bar()
```
#### 输出部分
```text
from A
```
类内部才可以通过__foo的形式访问到封装的属性。其实原理也与封装修改属性名称有关。封装在类定义时，将self.__foo()变形成self._A__foo()。这样就找到了已经封装的__foo属性。
- 子类无法覆盖父类同名的封装后的属性。因为子类中变形成了：_子类名__x,而父类中变形成了：_父类名__x，即双下滑线开头的属性在继承给子类时，子类是无法覆盖的。
#### 代码部分：
```python
class A:
    def __foo(self): #变形为_A__foo
        print('from A')


class B(A):
    def __foo(self):  # 变形为_B__foo
        print('from B')
```
如上子类的封装属性__foo虽然看上去与父类的__foo属性一样。但其实在类的定义阶段，这两个属性都被重名成不同的属性名称。所以子类和父类中重名的封装属性，子类并不能覆盖父类的封装属性。

封装的注意事项：
1、这种封装的变形机制也并没有真正意义上限制我们从外部直接访问属性，知道了类名和属性名就可以拼出名字：_类名__属性，然后就可以访问了，如a._A__N
2、变形的过程只在类的定义是发生一次,在定义后的赋值操作，不会变形
#### 代码部分
```python
class A:
    __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N
    def __init__(self, name):
        self.__name = name #变形为self._A__X

    def __foo(self): #变形为_A__foo
        print('from A')

    def bar(self):
        self.__foo() #只有在类内部才可以通过__foo的形式访问到。其实原理也是在类定义时，变形成self._A__foo


a = A('henry')
a.__Y = 1  # 给实例增加属性。
print('实例中的属性：%s' % a.__dict__)
```
#### 输出内容
```text
实例中的属性：{'_A__name': 'henry', '__Y': 1}
```
可以看到，类定义完后，实例时无法通过增加属性的方式添加一个封装的属性的。
3、在继承中，父类如果不想让子类覆盖自己的方法，可以将方法定义为私有的
```python
#正常情况
>>> class A:
...     def fa(self):
...         print('from A')
...     def test(self):
...         self.fa()
... 
>>> class B(A):
...     def fa(self):
...         print('from B')
... 
>>> b=B()
>>> b.test()
from B


#把fa定义成私有的，即__fa
>>> class A:
...     def __fa(self): #在定义时就变形为_A__fa
...         print('from A')
...     def test(self):
...         self.__fa() #只会与自己所在的类为准,即调用_A__fa
... 
>>> class B(A):
...     def __fa(self):
...         print('from B')
... 
>>> b=B()
>>> b.test()
from A
```


# **封装的意义**
封装并不止隐藏属性这么简单。我们来看一下封装用法的实际意义。
## 1 封装数据
将数据属性封装起来，可以隐藏起来然后对外提供操作该数据的接口，然后我们可以在接口附加上对该数据操作的限制，以此完成对封装数据属性的操作进行严格控制。
```python
class Teacher:
    def __init__(self,name,age):
        self.__name=name
        self.__age=age

    def tell_info(self):
        print('姓名:%s,年龄:%s' %(self.__name,self.__age))
    def set_info(self,name,age):  # 修改封装属性的接口函数
        if not isinstance(name,str):  # 对传入的参数进行一定的现在
            raise TypeError('姓名必须是字符串类型')
        if not isinstance(age,int):
            raise TypeError('年龄必须是整型')
        self.__name=name
        self.__age=age

t=Teacher('egon',18)
t.tell_info()

t.set_info('egon',19)  # 使用set_info接口函数，修改封装函数。
t.tell_info()
```

## 2. 封装方法：目的是隔离复杂度
类中可能定义了多种方法，但这些方法最后可以汇聚成一个接口。比如：电视机，电视机内部有很多电器元件，分别处理各自的功能。但对于
用户来说，我们不需要清楚里面元件的功能，我们只需要使用遥控器提供给用户的几个按钮来对电视机进行操作。
在这个比方中，电视机就是类，电器元件就是类中多种方法。遥控器就是接口，遥控器的按钮就是接口函数。
所以封装方法的目的，就是将原有类中复杂的方法集合起来。提供一个统一的接口函数。让外部直接去调用。
#### 
```python
#取款是功能,而这个功能有很多功能组成:插卡、密码认证、输入金额、打印账单、取钱
#对使用者来说,只需要知道取款这个功能即可,其余功能我们都可以隐藏起来,很明显这么做
#隔离了复杂度,同时也提升了安全性

class ATM:
    def __card(self):
        print('插卡')
    def __auth(self):
        print('用户认证')
    def __input(self):
        print('输入取款金额')
    def __print_bill(self):
        print('打印账单')
    def __take_money(self):
        print('取款')

    def withdraw(self):
        self.__card()
        self.__auth()
        self.__input()
        self.__print_bill()
        self.__take_money()

a=ATM()
a.withdraw()
```


提示：在编程语言里，对外提供的接口（接口可理解为了一个入口），可以是函数，称为接口函数，这与接口的概念还不一样，接口代表一组接口函数的集合体。

# **封装的可扩展性**
封装在于明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者的代码；而外部使用用者只知道一个接口(函数)，只要接口（函数）名、参数不变，
使用者的代码永远无需改变。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑。
```python
#类的设计者
class Room:
    def __init__(self,name,owner,width,length,high):
        self.name=name
        self.owner=owner
        self.__width=width
        self.__length=length
        self.__high=high
    def tell_area(self): #对外提供的接口，隐藏了内部的实现细节，此时我们想求的是面积
        return self.__width * self.__length


#使用者
>>> r1=Room('卧室','egon',20,20,20)
>>> r1.tell_area() #使用者调用接口tell_area


#类的设计者，轻松的扩展了功能，而类的使用者完全不需要改变自己的代码
class Room:
    def __init__(self,name,owner,width,length,high):
        self.name=name
        self.owner=owner
        self.__width=width
        self.__length=length
        self.__high=high
    def tell_area(self): #对外提供的接口，隐藏内部实现，此时我们想求的是体积,内部逻辑变了,只需求修该下列一行就可以很简答的实现,而且外部调用感知不到,仍然使用该方法，但是功能已经变了
        return self.__width * self.__length * self.__high


#对于仍然在使用tell_area接口的人来说，根本无需改动自己的代码，就可以用上新功能
>>> r1.tell_area()
```
# **特性（property）**
property是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值。property也是一个装饰器。
我们用一个例子来说明。就用计算房间面积的代码。（面积是计算而来的，很显然它更像是房子的一个属性而非方法）。
#### 代码部分
```python
class Room:
    def __init__(self,name,owner,width,length,high):
        self.name=name
        self.owner=owner
        self.__width=width
        self.__length=length
        self.__high=high
    
    def area(self):
        return self.__width * self.__length


#使用者
r1=Room('卧室','egon',20,20,20)
print(r1.area()) #使用者调用接口tell_area
```
如上代码，可以看到的是，对象调用面积时，使用了r1.area()他是一种调用方法的语句。对于这个对象的编写者就会产生一个疑惑。这个area明明像一个数据属性，
但为什么需要用方法的方式去调用哪？
哪对象是否可以使用调用数据属性的方式调用方法哪？
#### 代码部分
```python
class Room:
    def __init__(self, name, owner, width, length, high):
        self.name = name
        self.owner = owner
        self.__width = width
        self.__length = length
        self.__high = high

    @property
    def area(self):
        return self.__width * self.__length


# 使用者
r1 = Room('卧室', 'egon', 20, 20, 20)
print(r1.area)  # 使用调用数据属性的方式，调用了一个方法属性
```
所以@property装饰器的作用，就是原来调用方法的r1.area()方式，装饰为调用数据属性的r1.area方式。

# **property意义**
将一个类的函数定义成特性以后，对象再去调用的时候,根本无法察觉自己的调用的是一个方法，而不是数据属性。
特性的使用方式，是为了遵循了统一访问的原则：
    All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation
翻译：一个模块提供的所有服务都应该通过统一记号提供出来，这并不意味着它们是通过存储还是通过计算实现的。
也可以理解为，如果类中有方法是执行的计算代码，并且返回的数据可以作为对象的一个属性。就应该使用peroperty特性，将它的调用方式转换成数据属性的调用方式。

# ** propert扩展**
除此之外，看下
ps：面向对象的封装有三种方式:
【public】
这种其实就是不封装,是对外公开的
【protected】
这种封装方式对外不公开,但对朋友(friend)或者子类公开
【private】
这种封装对谁都不公开
python并没有在语法上把它们三个内建到自己的class机制中，在C++里一般会将所有的所有的数据都设置为私有的，然后提供set和get方法（接口）去设置和获取，在python中通过property方法可以实现
class Foo:
    def __init__(self,val):
        self.__NAME=val #将所有的数据属性都隐藏起来

    @property
    def name(self):
        return self.__NAME #obj.name访问的是self.__NAME(这也是真实值的存放位置)

    @name.setter
    def name(self,value):
        if not isinstance(value,str):  #在设定值之前进行类型检查
            raise TypeError('%s must be str' %value)
        self.__NAME=value #通过类型检查后,将值value存放到真实的位置self.__NAME

    @name.deleter
    def name(self):
        raise TypeError('Can not delete')

f=Foo('egon')
print(f.name)
# f.name=10 #抛出异常'TypeError: 10 must be str'
del f.name #抛出异常'TypeError: Can not delete'

面向对象开发的三大特性继承、多态、封装。

# 绑定方法与非绑定方法
在类内部定义的函数，分为两大类：
一、 绑定方法：绑定给谁，谁才能使用。
- 绑定到对象的方法：
在类内定义的没有被任何装饰器修饰的函数。就是一个绑定到对象的方法。只有绑定给的对象才能使用这个方法。
#### 代码部分
```pyton
class People:
    def __init__(self, name, ):
        self.name = name

    def tell(self):
        print(self.name)


p1 = People('henry')
print('打印p1对象:', p1)
print('打印p1对象的tell方法:',p1.tell)  # 绑定到对象的方法
```
#### 输出内容
```text
打印p1对象: <__main__.People object at 0x7f287c1e1390>
打印p1对象的tell方法: <bound method People.tell of <__main__.People object at 0x7f287c1e1390>>
```
如上代码的输出。我们可以确认，People类中的tell函数属性。是绑定给p1对象的一个办法( <bound method People.tell of <\_\_main\_\_.People object at 0x7f287c1e1390>>)。
所以总结一下，绑定给对象的方法。就是，将一个方法绑定给一个对象，就应该由该对象来调用，对象来调用的话，就把调用对象，当做第一个参数自动传入。
- 绑定到类的方法:在类内定义的被任何装饰器classmethod修饰的函数
#### 代码部分
```python
class People:
    def __init__(self, name, ):
        self.name = name

    def tell(self):
        print(self.name)

    @classmethod
    def func(cls):
        print(cls)


p1 = People('henry')
print('打印People类的命名空间:', People)
print('打印的绑定给People类的func方法的命名空间:',People.func)  # 绑定到类的方法
print('打印p1对象调用func方法的命名空间:', p1.func)  # 就算是类的对象来调用该方法。该方法还是绑定给类的。
```
#### 输出内容
```text
打印People类的命名空间: <class '__main__.People'>
打印的绑定给People类的func方法的命名空间: <bound method People.func of <class '__main__.People'>>
打印p1对象调用func方法的命名空间: <bound method People.func of <class '__main__.People'>>
```
如上代码可以确认，People类中的func函数属性。是绑定给People类的一个办法(  <bound method People.func of <class '__main__.People'>>)。就算是类的实例去调用方法，
它还是绑定给People类的一个方法。
所以总结一下，绑定给类的方法。就是，将一个方法绑定给一个类，就应该由该类来调用，类来调用的话，就把调用类，当做第一个参数自动传入。
二、非绑定方法：
在类内定义的被装饰器staticmethod修饰的函数。被装饰后，该方法就变成了一个普通的函数，不与类和对象绑定的方法。不进行自动传self、cls值。类和对象都可以使用这个函数。
#### 代码部分
```python
class People:
    def __init__(self, name, ):
        self.name = name

    def tell(self):
        print(self.name)

    @classmethod
    def func(cls):
        print(cls)

    @staticmethod
    def foo(age):
        print(age)

p1 = People('henry')
print('打印People类调用foo方法的命名空间:',People.foo)  # foo非绑定到People类
print('打印p1对象调用foo方法的命名空间:', p1.foo)  # foo非绑定到p1对象

# 非绑定方法foo的使用。就像普通的一个函数。
People.foo(12)  # 
p1.foo(13)

```
#### 输出内容
```text
打印People类调用foo方法的命名空间: <function People.foo at 0x7f1de1cf02f0>
打印p1对象调用foo方法的命名空间: <function People.foo at 0x7f1de1cf02f0>
12
13
```
如上代码可以确认，foo方法没有绑定给类、对象。它就是一个普通的函数(  <function People.foo at 0x7f1de1cf02f0>)。

# 绑定方法和非绑定方法的应用。
我们通过一个案例来讲一个绑定方法与非绑定方法在实际项目中如何去使用。
```python
class People:
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex

    def tell_info(self):  # 绑定给对象的方法
        obj_info = """-------PEOPLE INFO--------
        Name:    %s
        Age:     %s
        Sex:     %s 
        """ % (self.name, self.age, self.sex)
        print(obj_info)


# 绑定给对象的方法，就应该对象来调用。
henry = People('henry',29,'man')
henry.tell_info()
```
首先，tell_info方法是一个打印对象信息的方法。这个方法中的name、age、sex都是对象的独有属性。需要在实例化对象时导入。所以，
tell_info方法必须使用绑定到对象的方法。
我们现在增加一个功能，需要用户信息可以通过配置文件进行导入,最终实例化成为一个对象。并且，这个配置文件导入的功能必须是People类的一个方法。
修改代码如下：
```python
import settings
class People:
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex

    def tell_info(self):  # 绑定给对象的方法
        obj_info = """-------PEOPLE INFO--------
        Name:    %s
        Age:     %s
        Sex:     %s 
        """ % (self.name, self.age, self.sex)
        print(obj_info)

    def import_conf(whatever):  # whatever只是一个参数，而不是指代任何对象。虽然没有定义staticmethod装饰器，但这个方法的本质就是一个非绑定方法
        obj = People(settings.name, settings.age, settings.sex)  # 创建一个People类的对象。这个对象所有的参数来源是settings这个配置文件
        return obj  # 返回这个对象


jerry = People.import_conf(123123)
jerry.tell_info()
```
这段代码的import_conf方法并不是一个绑定给对象的方法。它本质上是一个非绑定方法。因为在它的函数内部的所有代码并没有用到任何对象或类。
通过在这个import_conf方法中实例化一个从settings配置文件中，导入各个参数的对象。并返回这个对象的方式。生成了一个从配置文件导入的对象。
但如上的代码有个重大的缺陷，就是People这个类名，可能会发生改变。所以更好的方法是使用绑定类的方法来进行编写。
```python
import settings
class People:
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex

    def tell_info(self):  # 绑定给对象的方法
        obj_info = """-------PEOPLE INFO--------
        Name:    %s
        Age:     %s
        Sex:     %s 
        """ % (self.name, self.age, self.sex)
        print(obj_info)

    @classmethod
    def import_conf(cls):  # 绑定给类的方法
        obj = cls(settings.name, settings.age, settings.sex)  # 产生obj对象的类，由cls参数导入。
        return obj  # 返回这个对象


# 绑定给类的方法，就应该对象来调用。
jerry = People.import_conf()
jerry.tell_info()
```
再增加一个需求，需要给每个对象创建一个唯一的id号。这个id号由创建时间进行MD5校验而来。
```python
import settings
import hashlib
import time

class People:
    def __init__(self, name, age, sex):
        self.id = self.create_id()  # 每个对象都可以调用create_id非绑定方法，生成ID。并作为自己的属性
        self.name = name
        self.age = age
        self.sex = sex

    def tell_info(self):  # 绑定给对象的方法
        obj_info = """-------PEOPLE INFO--------
        ID:      %s
        Name:    %s
        Age:     %s
        Sex:     %s 
        """ % (self.id, self.name, self.age, self.sex)
        print(obj_info)

    @classmethod
    def import_conf(cls):
        obj = cls(settings.name, settings.age, settings.sex)  # 产生obj对象的类，由cls参数导入。
        return obj  # 返回这个对象


    @staticmethod
    def create_id():  # 非绑定方法，代码内部并不需要对象和类传递进来。
        id = hashlib.md5(str(time.time()).encode('utf-8'))  # 计算MD5值。
        return id.hexdigest()


# 绑定给对象的方法，就应该对象来调用
henry = People('henry', 29, 'man')
henry.tell_info()
# 绑定给类的方法，就应该类来调用。
jerry = People.import_conf()
jerry.tell_info()
# 非绑定方法，不与类和对象绑定，谁都可以调用。
```
如上代码可以看到。create_id方法，由于它内部的代码并没有使用到类和对象。所以它就应该是一个非绑定方法。并且非绑定方法，类和对象都可以使用。通过在构造函数中，self.id = self.create_id()
的方式。每次实例化对象时，都会使用create_id方法生成一个对象的id属性。
# 总结
所以使用这些方法时，需要根据实际方法的编写情况。
- 如方法中，需要有对象的存在。那就使用绑定对象的方法。既，不使用装饰器的函数属性
- 如方法中，需要有类的存在。那就使用绑定类的方法。既，使用classmethod装饰器的函数属性
- 如方法中，不需要类、对象的存在。那就使用非绑定方法。既，使用staticmethod装饰器的函数属性

# 一、前言
 test.py
import test as ss

ss.f1()
ss.f2()
print(ss.a)
　我们要导入另外一个模块,可以使用import.现在有这样的需求,我动态输入一个模块名，可以随时访问到导入模块中的方法或者变量，怎么做呢？

    imp = input(“请输入你想导入的模块名:”)
    CC = __import__(imp) 這种方式就是通过输入字符串导入你所想导入的模块 
    CC.f1()  # 执行模块中的f1方法
 　　上面我们实现了动态输入模块名，从而使我们能够输入模块名并且执行里面的函数。但是上面有一个缺点，那就是执行的函数被固定了。那么，我们能不能改进一下，动态输入函数名，并且来执行呢？

复制代码
#dynamic.py
imp = input("请输入模块:")
dd = __import__(imp)
# 等价于import imp
inp_func = input("请输入要执行的函数：")

f = getattr(dd,inp_func，None)#作用:从导入模块中找到你需要调用的函数inp_func,然后返回一个该函数的引用.没有找到就烦会None

f() # 执行该函数
复制代码
　　上面我们就实现了，动态导入一个模块，并且动态输入函数名然后执行相应功能。

　　当然，上面还存在一点点小问题:那就是我的模块名有可能不是在本级目录中存放着。有可能是如下图存放方式：

　　

　　那么这种方式我们该如何搞定呢?看下面代码:

dd = __import__("lib.text.commons")  #这样仅仅导入了lib模块
dd = __import__("lib.text.commons",fromlist = True)  #改用这种方式就能导入成功
# 等价于import config
inp_func = input("请输入要执行的函数：")
f = getattr(dd,inp_func)
f()

# 反射
---
反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。
这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。

在python中面向对象的反射的体现，就是通过字符串的形式操作到对象的属性(python中任何东西都是一个对象)。如何理解这句话？有时可能需要通过用户输入的字符串，
来调用对象的方法。但默认，程序是无法通过直接输入的字符串来调用方法的。所以需要使用反射来进行操作。
python中使用如下四个函数来进行反射。下列的函数，适合类、对象还有模块导入：
- 检查一个对象中是否有指定的方法或熟悉
hasattr(obj/class, 'name'') # 返回一个布尔值。判断obj__dict__下有没有name这个key。
拿到一个对象的属性：
getattr(obj/class, 'name',None)
None当没有name属性时。返回None，而不是报错。
设置一个对象的属性
setattr(obj/class,'sex','male'')
删除一个对象的属性
delattr(obj/class,'age')
## 四个方法的演示
```python
class BlackMedium:
    feature='Ugly'
    def __init__(self,name,addr):
        self.name=name
        self.addr=addr

    def sell_house(self):
        print('%s 黑中介卖房子啦,傻逼才买呢,但是谁能证明自己不傻逼' %self.name)
    def rent_house(self):
        print('%s 黑中介租房子啦,傻逼才租呢' %self.name)

b1=BlackMedium('万成置地','回龙观天露园')

#检测是否含有某属性
print(hasattr(b1,'name'))
print(hasattr(b1,'sell_house'))

#获取属性
n=getattr(b1,'name')
print(n)
func=getattr(b1,'rent_house')
func()

# getattr(b1,'aaaaaaaa') #报错
print(getattr(b1,'aaaaaaaa','不存在啊'))

#设置属性
setattr(b1,'sb',True)
setattr(b1,'show_name',lambda self:self.name+'sb')
print(b1.__dict__)
print(b1.show_name(b1))

#删除属性
delattr(b1,'addr')
delattr(b1,'show_name')
delattr(b1,'show_name111')#不存在,则报错

print(b1.__dict__)
```
在类中的使用：
```python
class Foo(object):

    staticField = "old boy"

    def __init__(self):
        self.name = 'wupeiqi'

    def func(self):
        return 'func'

    @staticmethod
    def bar():
        return 'bar'

print getattr(Foo, 'staticField')
print getattr(Foo, 'func')
print getattr(Foo, 'bar')
```
在模块中使用
反射当前模块成员

#!/usr/bin/env python
# -*- coding:utf-8 -*-

import sys


def s1():
    print 's1'


def s2():
    print 's2'


this_module = sys.modules[__name__]

hasattr(this_module, 's1')
getattr(this_module, 's2')
导入其他模块，利用反射查找该模块是否存在某个方法
module_test.py
#!/usr/bin/env python
# -*- coding:utf-8 -*-

"""
程序目录：
    module_test.py
    index.py

当前文件：
    index.py
"""

import module_test as obj

#obj.test()

print(hasattr(obj,'test'))

getattr(obj,'test')()
# 反射的用法
---
我们来看一下反射在实际项目中的使用方法。我们假设自己编写一个ftp的客户端，它支持get、put文件。并且提供用户输入的get、put方式去执行对应的方法。
```python
class FTP_client:
    def __init__(self, ip, port, user, password):  # 定义一个IP、端口、用户、密码的构建函数
        self.ip = ip
        self.port = port
        self.user = user
        self.password = password

    def __check(self):  # 也可以定义各一个检查的封装函数,只在类的内部使用所以镜像了封装。进行密码规范的检查。这里就不详细展开了。
        pass

    def run(self):  # 运行方法。每个实例调用一个run方法来执行ftp客户端的登录。
        while True:
            inp = input('cmd > ')
            cmds = inp.split()
            if hasattr(self, cmds[0]):  # 检查对象中是否有用户输入的方法。
                func = getattr(self, cmds[0])  # 如果有的话，获取该方法
                func(cmds)  # 并执行该方法
            else:
                print('Command error')

    def get(self, cmds):
        print('Start! get %s' % cmds[1])

    def put(self, cmds):
        print('Start! put %s' % cmds[1])


ftp1 = FTP_client('10.1.1.1',22,'henry','henry')
ftp1.run()
```



#使用反射的好处
---
- 实现可插拔机制
有俩程序员，一个lili，一个是egon，lili在写程序的时候需要用到egon所写的类，但是egon去跟女朋友度蜜月去了，还没有完成他写的类，lili想到了反射，使用了反射机制lili可以继续完成自己的代码，等egon度蜜月回来后再继续完成类的定义并且去实现lili想要的功能。
总之反射的好处就是，可以事先定义好接口，接口只有在被完成后才会真正执行，这实现了即插即用，这其实是一种‘后期绑定’，什么意思？即你可以事先把主要的逻辑写好（只定义接口），然后后期再去实现接口的功能
egon还没有实现全部功能
class FtpClient:
    'ftp客户端,但是还么有实现具体的功能'
    def __init__(self,addr):
        print('正在连接服务器[%s]' %addr)
        self.addr=addr
不影响lili的代码编写
#from module import FtpClient
f1=FtpClient('192.168.1.1')
if hasattr(f1,'get'):
    func_get=getattr(f1,'get')
    func_get()
else:
    print('---->不存在此方法')
    print('处理其他的逻辑')
    
- 动态导入模块（基于反射当前模块成员）
ython提供了一个特殊的方法：__import__(字符串参数)。通过它，我们就可以实现类似的反射功能。__import__()方法会根据参数，动态的导入同名的模块。

我们再修改一下上面的visit模块的代码。

def run():
  inp = input("请输入您想访问页面的url： ").strip()
  modules, func = inp.split("/")
  obj = __import__(modules)
  if hasattr(obj, func):
    func = getattr(obj, func)
    func()
  else:
    print("404")
  
if __name__ == '__main__':
  run()
  
  
# 内置方法
一 isinstance(obj,cls)和issubclass(sub,super)
isinstance(obj,cls)检查是否obj是否是类 cls 的对象
```python
class Foo(object):
    pass
obj = Foo()
isinstance(obj, Foo)
```
issubclass(sub, super)检查sub类是否是 super 类的派生类
```python
class Foo(object):
    pass
class Bar(Foo):
    pass
issubclass(Bar, Foo)
```

三 __setattr__,__delattr__,__getattr__
三者的用法演示
```python
class Foo:
    x=1
    def __init__(self,y):
        self.y=y

    def __getattr__(self, item):
        print('----> from getattr:你找的属性不存在')


    def __setattr__(self, key, value):
        print('----> from setattr')
        # self.key=value #这就无限递归了,你好好想想
        # self.__dict__[key]=value #应该使用它

    def __delattr__(self, item):
        print('----> from delattr')
        # del self.item #无限递归了
        self.__dict__.pop(item)

#__setattr__添加/修改属性会触发它的执行
f1=Foo(10)
print(f1.__dict__) # 因为你重写了__setattr__,凡是赋值操作都会触发它的运行,你啥都没写,就是根本没赋值,除非你直接操作属性字典,否则永远无法赋值
f1.z=3
print(f1.__dict__)

#__delattr__删除属性的时候会触发
f1.__dict__['a']=3#我们可以直接修改属性字典,来完成添加/修改属性的操作
del f1.a
print(f1.__dict__)

#__getattr__只有在使用点调用属性且属性不存在的时候才会触发
f1.xxxxxx
```
七 __setitem__,__getitem__,__delitem__
将对象的属性定制成以一种字典形态进行增、删、改的python1内置方法。
```python
class Foo:
    def __init__(self,name):
        self.name=name

    def __getitem__(self, item):
        print(self.__dict__[item])

    def __setitem__(self, key, value):
        self.__dict__[key]=value
    def __delitem__(self, key):
        print('del obj[key]时,我执行')
        self.__dict__.pop(key)
    def __delattr__(self, item):
        print('del obj.key时,我执行')
        self.__dict__.pop(item)

f1=Foo('sb')
f1['age']=18
f1['age1']=19
del f1.age1
del f1['age']
f1['name']='alex'
print(f1.__dict__)
```
八 __str__,__repr__,__format__
改变对象的字符串显示__str__,__repr__
自定制格式化字符串__format__
```python
#_*_coding:utf-8_*_
__author__ = 'Linhaifeng'
format_dict={
    'nat':'{obj.name}-{obj.addr}-{obj.type}',#学校名-学校地址-学校类型
    'tna':'{obj.type}:{obj.name}:{obj.addr}',#学校类型:学校名:学校地址
    'tan':'{obj.type}/{obj.addr}/{obj.name}',#学校类型/学校地址/学校名
}
class School:
    def __init__(self,name,addr,type):
        self.name=name
        self.addr=addr
        self.type=type

    def __repr__(self):
        return 'School(%s,%s)' %(self.name,self.addr)
    def __str__(self):
        return '(%s,%s)' %(self.name,self.addr)

    def __format__(self, format_spec):
        # if format_spec
        if not format_spec or format_spec not in format_dict:
            format_spec='nat'
        fmt=format_dict[format_spec]
        return fmt.format(obj=self)

s1=School('oldboy1','北京','私立')
print('from repr: ',repr(s1))
print('from str: ',str(s1))
print(s1)

'''
str函数或者print函数--->obj.__str__()
repr或者交互式解释器--->obj.__repr__()
如果__str__没有被定义,那么就会使用__repr__来代替输出
注意:这俩方法的返回值必须是字符串,否则抛出异常
'''
print(format(s1,'nat'))
print(format(s1,'tna'))
print(format(s1,'tan'))
print(format(s1,'asfdasdffd'))
```
十三 __del__
我们知道了__init__是构造方法，哪__del__是析构方法。它的作用是，当对象在内存中被释放时，自动触发执行。
可以通过使用它，在实例从内存中删除时进行一些操作。
注：如果产生的对象仅仅只是python程序级别的（用户级），那么无需定义__del__,如果产生的对象的同时还会向操作系统发起系统调用，
即一个对象有用户级与内核级两种资源，比如（打开一个文件，创建一个数据库链接），则必须在清除对象的同时回收系统资源，这就用到了__del__。
简单示范
```python
class Foo:

    def __del__(self):
        print('执行我啦')

f1=Foo()
del f1
print('------->')

#输出结果
执行我啦
------->
挖坑埋了你
class Foo:

    def __del__(self):
        print('执行我啦')

f1=Foo()
# del f1
print('------->')

#输出结果
------->
执行我啦


#为何啊？？？
```

典型的应用场景：
创建数据库类，用该类实例化出数据库链接对象，对象本身是存放于用户空间内存中，而链接则是由操作系统管理的，存放于内核空间内存中
当程序结束时，python只会回收自己的内存空间，即用户态内存，而操作系统的资源则没有被回收，这就需要我们定制__del__，在对象被删除前向操作系统发起关闭数据库链接的系统调用，回收资源+

这与文件处理是一个道理：
f=open('a.txt') #做了两件事，在用户空间拿到一个f变量，在操作系统内核空间打开一个文件
del f #只回收用户空间的f，操作系统的文件还处于打开状态

#所以我们应该在del f之前保证f.close()执行,即便是没有del，程序执行完毕也会自动del清理资源，于是文件操作的正确用法应该是
f=open('a.txt')
读写...
f.close()
很多情况下大家都容易忽略f.close,这就用到了with上下文管理
总结
- python中以__XXX__格式的内置方法，会在某种情况下自动触发执行。帮助将程序中的类进行定制化

# 元类
## 前言(exec函数)

二 引子（类也是对象）
python中一切皆是对象,如何去深入理解这句话？符合如下4个规范的就是一个对象：
1. 赋值给一个变量。X = obj
2. 作为函数参数进行传递
3. 作为函数的返回值
4. 可以作为容器类的元素。列表中可以放函数、模块、等l=[func, time,]

我们来看一下类是否符合这4个规范
1. 把类赋值给一个变量
2. 把类作为函数参数进行传递
3. 把类作为函数的返回值
4. 在运行时动态地创建类
所以类也是一个对象。当使用关键字class的时候，python解释器在加载class的时候就会创建一个对象(这里的对象指的是类而非类的实例)，因而我们可以将类当作一个对象去使用
```python
class Foo:
      pass

f1=Foo() #f1是通过Foo类实例化的对象
print(type(obj))  # 由Foo类实例化而来
print(type(Foo))   # 由type类实例化而来 Foo=type(...)
```

上例可以看出f1是由Foo这个类产生的对象，而Foo本身也是对象，那它又是由哪个类产生的呢？
#type函数可以查看类型，也可以用来查看对象的类，二者是一样的
print(type(f1)) # 输出：<class '__main__.Foo'> 表示，obj 对象由Foo类创建
print(type(Foo)) # 输出：<type 'type'>

我们发现type这个类是一个制造类的类。所以这里经引出了元类，元类就是一个制造类的类。所以type类就是python中其他类的元类。

# 元类
产生类的类称之为元类，默认所有用class定义的类，的元类都是type类。
#＃　创建类的两种方式：
在讲解创建元类前。我们先来看一下创建类的两种方式
1. 方式一：class
```python
class Chinese(object):
    country='China'
    def __init__(self,name,age):
        self.name=name
        self.age=age
    def talk(self):
        print('%s is talking' %self.name)
```
2. 方式二：就是手动模拟class创建类的过程）：将创建类的步骤拆分开，用type函数去创建类
定义类的三要素：
1. 类名
2. 继承的父类
3. 类体代码
```python
#类名
class_name='Chinese'
#类的父类
class_bases=(object,)
#类体
class_body="""
country='China'
def __init__(self,name,age):
    self.name=name
    self.age=age
def talk(self):
    print('%s is talking' %self.name)
"""
```
步骤一（先处理类体->名称空间）：类体定义的名字都会存放于类的名称空间中（一个局部的名称空间），我们可以事先定义一个空字典，然后用exec去执行类体的代码（exec产生名称空间的过程与真正的class过程类似，只是后者会将__开头的属性变形），生成类的局部名称空间，即填充字典
```python
class_dic={}
exec(class_body ,globals(), class_dic)
print(class_dic)
#{'country': 'China', 'talk': <function talk at 0x101a560c8>, '__init__': <function __init__ at 0x101a56668>}
```

步骤二：调用元类type（也可以自定义）来产生类Chinense
```python
Chinese=type(class_name,class_bases,class_dic) #实例化type得到对象Chinese，即我们用class定义的类Foo


print(Foo)
print(type(Foo))
print(isinstance(Foo,type))
'''
<class '__main__.Chinese'>
<class 'type'>
True
'''
```

我们看到，type 接收三个参数：
第 1 个参数是字符串 class_name，表示类名
第 2 个参数是元组 (object, )，表示所有的父类
第 3 个参数是字典，这里是一个空字典，表示没有定义属性和方法
补充：若Foo类有继承，即class Foo(Bar):.... 则等同于type('Foo',(Bar,),{})

这两种类实例化后的结果都是一样的。

# 自定义元类控制类的创建
使用自己创建的元类对类的创建进行一定的控制。
如下代码通过自己创建一个Mymeta的元类，来控制其他类的命名规范和注释规范
```python
#步骤一：如果说People=type(类名,类的父类们,类的名称空间)，那么我们定义元类如下，来控制类的创建
class Mymeta(type):  # 需要去继承type元类的属性
    def __init__(self, class_name, class_bases, class_dic):
        if '__doc__' not in class_dic or not class_dic.get('__doc__').strip():  # 类的主体必须有注释
            raise TypeError('必须为类指定文档注释')

        if not class_name.istitle():  # 类的名字必须大小写
            raise TypeError('类名首字母必须大写')

        super(Mymeta, self).__init__(class_name, class_bases, class_dic)  # 重用父类type类的构造方法


# class People(object, metaclass=Mymeta) 等于People = Mymeta(class_name, class_bases, class_dic)
class People(object, metaclass=Mymeta):
    country = 'China'

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def talk(self):
        print('%s is talking' % self.name)
```

# 自定义元类控制实例化行为

#储备知识__call__方法的使用
我们知道使用obj=class(）语句，可以调用类来实例化一个对象。哪这里就有一个疑问。python中一切皆对象，obj也是一个对象，哪它是否可以被调用哪？
我们来看一下如下代码obj是否可以被调用：
#### 代码部分
```python
class Foo:
    pass


obj = Foo()
obj()
```
#### 输出内容
```text
Traceback (most recent call last):
  File "I:/python_project/first-app/homework/test.py", line 5, in <module>
    obj()
TypeError: 'Foo' object is not callable
```
可以发现程序报错了，所Foo的对象没有调用的能力。哪obj是否就打破了python中一切皆对象的定义，它不是一个对象哪？并不是，使用__call__方法就可以让obj对象被调用。如下代码。
```python
class People(object,metaclass=type):
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def __call__(self, *args, **kwargs):
        print(self,args,kwargs)


# 调用类People，并不会出发People类的__call__方法
obj=People('egon',18)

# 调用对象obj(1,2,3,a=1,b=2,c=3)，才会触发对象的绑定方法obj.__call__(1,2,3,a=1,b=2,c=3)
obj(1,2,3,a=1,b=2,c=3) #打印：<__main__.People object at 0x10076dd30> (1, 2, 3) {'a': 1, 'b': 2, 'c': 3}
```
如上代码，就可以让obj对象可以被调用了。
那再来看一下实例化对象时的语句obj=People('egon',18)。People类的元类是type类，那么People类也是type类的一个实例化后的对象。所以在元类type内肯定也有一个__call__，会在调用People('egon',18)时触发执行，然后返回一个初始化好了的对象obj
所以我们也可以在自定义的元类中使用__call__方法来控制类的调用（实例化）过程中的操作
```python
#步骤三：自定义元类，控制类的调用（即实例化）的过程
class Mymeta(type): #继承默认元类的一堆属性
    def __init__(self,class_name,class_bases,class_dic):
        if not class_name.istitle():
            raise TypeError('类名首字母必须大写')

        super(Mymeta,self).__init__(class_name,class_bases,class_dic)

    def __call__(self, *args, **kwargs):
        #self=People
        print(self,args,kwargs) #<class '__main__.People'> ('egon', 18) {}

        #1、实例化People，产生空对象obj
        obj=object.__new__(self)


        #2、调用People下的函数__init__，初始化obj
        self.__init__(obj,*args,**kwargs)


        #3、返回初始化好了的obj
        return obj

class People(object,metaclass=Mymeta):
    country='China'

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def talk(self):
        print('%s is talking' %self.name)

obj=People('egon',18)  # People.__call__（People, 'egon', 18）
print(obj.__dict__) #{'name': 'egon', 'age': 18}

#步骤四：
class Mymeta(type): #继承默认元类的一堆属性
    def __init__(self,class_name,class_bases,class_dic):
        if not class_name.istitle():
            raise TypeError('类名首字母必须大写')

        super(Mymeta,self).__init__(class_name,class_bases,class_dic)

    def __call__(self, *args, **kwargs):
        #self=People
        print(self,args,kwargs) #<class '__main__.People'> ('egon', 18) {}

        #1、调用self，即People下的函数__new__，在该函数内完成：1、产生空对象obj 2、初始化 3、返回obj
        obj=self.__new__(self,*args,**kwargs)

        #2、一定记得返回obj，因为实例化People(...)取得就是__call__的返回值
        return obj

class People(object,metaclass=Mymeta):
    country='China'

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def talk(self):
        print('%s is talking' %self.name)

    def __new__(cls, *args, **kwargs):
        obj=object.__new__(cls)
        cls.__init__(obj,*args,**kwargs)
        return obj

obj=People('egon',18)
print(obj.__dict__) #{'name': 'egon', 'age': 18}
```


