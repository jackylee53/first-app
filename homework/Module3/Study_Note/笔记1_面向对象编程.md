## **第一章：面向对象编程与面向过程编程**
#### **1.面向过程编程**
面向过程的编程，就是将一个大的任务拆分成多个小任务。完成了所有的小任务，也就完成了整个任务
###### 优点:
1. 将负责的问题流程化，进而简单化。
2. 运行速度快
###### 缺点：
1. 扩展性非常差。当需要增加代码时，就捉襟见肘，需要修改多处。
###### 使用方法:
- 适合用于一些简单的自动化，监控脚本中。

#### **2.面向对象编程**
我们可能之前听说过“python一起都对象”的说法。
在面向对象编程之前，需要了解什么是对象？
我们可以这样理解，对象是可以对其做事情的一些东西。这个对象有一定的特征和技能，可以处理你要求它做的事情。
###### 优点:
1. 可扩展性强。
###### 缺点：
1. 编程复杂度高。
###### 使用方法:
- 适合用于一些简单的自动化，监控脚本中。
## **第二章：如何使用面向对象编写程序**
#### **1.概述**
首先我们看一下面向对象编程中牵涉到一些概念。
面向对象技术简介
- 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
(打个比方：如Henry，Tom是两个人，无论Henry和Tom他们个体都是是属于一个对象。那么它的类就是——人类。Henry、Tom共有的属性，比如他们有年龄，名字，工作、等。
Henry、Tom共有的方法，比如：说话，吃饭，走路，等)
- 类的属性：类的属性包含两个属性(数据属性、函数属性)：
> - 数据属性：类中定义的变量。类变量概念如下：
>>> - 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
> - 函数属性：类中定义的函数。（函数属性，也可以理解为是实例的方法）
- 实例化：创建一个类的实例，类的具体对象。（打个比方：我们使用人类这个类定义Jerry。那么Jerry就是人类这个类的一个实例化出来的对象）
- 实例变量：定义在类中__init__函数属性中的变量，只作用于当前实例的变量，也是当前实例自己独有的属性。
- 实例：使用类创建的一个个对象，包含类变量、实例变量、和类的函数变量。(打个比方：Jerry就是用人类这个类，
最后生成的实例)。实例还包含两个内容（属性和方法）：
> - 属性：类变量和实例变量都是对象的属性。
> - 方法：类的函数属性就是对象的方法。
- 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。
- 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
- 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。


- 对象：通过类定义的数据结构实例化而得的就是对象。对象包括两个数据成员（类变量和实例变量）和方法。
## ** 第三章：类的使用**
#### **1.定义类**
###### ** 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def learn(self):  # 定义类的函数属性
        print('learning')

    def eat(self):
        print('eating')
```


#### **3. 使用类——实例化对象**
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def learn(self):  # 定义类的函数方法
        print('learning')

    def eat(self):
        print('eating')
        
persion1 = Persion()  # 创建实例化对象persion1
```
使用persion1 = Persion()语句。就使用了Persion类实例化了一个persion1的对象。
#### **4. 类的执行过程**
类会在定义阶段就执行内部的代码，并放入名称空间。与函数不同，函数只是在调用时才会执行。
#### **5. 调用类的数据属性**
调用类的数据属性方法：
###### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def learn(self):  # 定义类的函数属性
        print('learning')

    def eat(self):
        print('eating')

stu_star = Persion.star  # 调用类的数据属性
print(stu_star)
```
###### 输出内容：
```text
earth
```
#### **6. 增加类的数据属性**
增加类的数据属性方法：
###### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

Persion.country = 'china'  # 增加的数据属性
print(Persion.__dict__)
```
###### 输出内容：
```text
{'__module__': '__main__', 'star': 'earth', 'learn': <function Persion.learn at 0x7f8b36d1a158>, 'eat': <function Persion.eat at 0x7f8b36d1a1e0>,
 '__dict__': <attribute '__dict__' of 'Persion' objects>, '__weakref__': <attribute '__weakref__' of 'Persion' objects>, '__doc__': None, 'country': 'china'}
```
#### **7.删除类的数据属性**
删除类的数据属性方法：
###### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

del Persion.star  # 删除类的数据属性
print(Persion.__dict__)
```
###### 输出内容：
```text
{'__module__': '__main__', 'learn': <function Persion.learn at 0x7f0c21f17158>, 'eat': <function Persion.eat at 0x7f0c21f171e0>, '__dict__': <attribute '__dict__' of 'Persion' objects>, 
'__weakref__': <attribute '__weakref__' of 'Persion' objects>, '__doc__': None}
```

#### ** 8.修改类的数据属性**
修改类的属性方法如下：
###### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

Persion.star = 'mars'  # 修改类的数据属性
print(Persion.__dict__)
```
###### 输出内容：
```text
{'__module__': '__main__', 'star': 'mars', 'learn': <function Persion.learn at 0x7ff494004158>, 'eat': <function Persion.eat at 0x7ff4940041e0>, 
'__dict__': <attribute '__dict__' of 'Persion' objects>, '__weakref__': <attribute '__weakref__' of 'Persion' objects>, '__doc__': None}
```
#### ** 9. 类的特殊属性**
类中除了数据属性和函数属性，还有一些自己的特殊属性。
```text
C.__name__：类的名字（字符串）
C.__doc__：类的文档字符串
C.__bases__：类的所有父类构成的元组
C.__dict__：类的所有属性
C.__module__：类定义所在的模块
C.__class__：实例所对应的类

```

## **第四章：对象的使用**
#### ** 1. 构造函数——__init__()**
我们先看一下如下的代码
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

persion1 = Persion()
```
我们定义了一个人类的类，创建了一个star的数据属性和2个learn、eat的函数属性（方法）。
并实例化了第一个人类的对象persion1。但是这时，可能你会发现Persion1这个对象，
并不止有star这个属性，他还有name、age、sex等属性。那我们应该怎么在类中定义一些可变的属性呢？这里引出__init__函数属性。
由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。
通过定义一个特殊的__init__方法，在创建实例的时候，就把可变的属性绑上去。修改代码如下：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
print(persion1.__dict__)
persion2 = Persion('Tom',20, 'man')  # 创建类的实例对象“TOM”
print(persion2.__dict__)
```
###### 输出内容：
```text
{'name': 'Jerry', 'age': 28, 'sex': 'man'}
{'name': 'Tom', 'age': 20, 'sex': 'man'}
```
我们可以看到，这时在创建类的实例对象时。需要向类导入四个实例变量。“self, name, age, sex”。
通过创建实例时，实例变量的导入。就可以为不同的实例创建不同的属性了。
#### ** 2.self概念**
大家看到如上代码中类的函数属性的形参都会自动加上一个“self”产生疑问。这个self是什么？<br>
- self：是个对象（Object），是当前类的实例自己。

因此，对应的self.name = name这段代码含义。就是为实例persion1创建一个name变量，
并且使用创建实例时倒入的name变量就行赋值。（可查阅上面章节的“调用类的数据属性”）
#### ** 3.实例化过程**
我们具体来讲一下如上代码的实例化过程：
1. 首先persion1实例会像内存申请一个空的内存空间，命名为persion1。
2. 其次persion1实例将自己的命名空间和其他需要传导的实例属性传递给Persion类。
3. 类中的__init__(self, name, age, sex)构建函数，
获取persion1实例的名字空间（self）和其他参数（name, age, sex），进行函数内部的处理。
4. self.name = name在persion1实例的名字空间中创建一个新的name变量，并用传导进入的实参进行赋值
5. 将处理后的结果返回给persion1的名称空间

#### ** 4.调用实例的实例属性**
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
print('Name: %s' % persion1.name)  # 打印实例属性

```
###### 输出内容：
```text
Name: Jerry
Star: earth
```
#### ** 5.增加实例的实例属性**
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion1.phone = '12345678910'  # 添加实例属性
print('Phone: %s' % persion1.phone)  # 打印增加的属性
```
###### 输出内容：
```text
Phone: 12345678910
```
#### ** 6.删除实例的实例属性**
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion1.phone = '12345678910'  # 添加实例属性
print('Phone: %s' % persion1.phone)  # 打印增加的属性
del persion1.phone  # 删除phone实例属性
print('Phone: %s' % persion1.phone)  # 再次打印报错
```
###### 输出内容：
```text
Phone: 12345678910
Traceback (most recent call last):
  File "/development/homework/test.py", line 19, in <module>
    print('Phone: %s' % persion1.phone)  # 再次打印报错
AttributeError: 'Persion' object has no attribute 'phone'
```
#### ** 7.修改实例的实例属性**
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion1.age = 48  # 修改age的实例属性
print('Age: %s' % persion1.age)  # 打印修改后的age
```
###### 输出内容：
```text
Age: 48
```
## **第五章：实例属性查找与绑定方法**
#### **1直接调用类是否可行？**
在开始讲实例调用类属性方法之前。现有一个问题，那就是python是否直接可以去调用类中的数据属性和函数属性。当然是可以的？
###### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性

    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        return ('%s is learning %s' % (self, lesson))

    def eat(self):
        return ('%s is eating' % self.name)

print('并非使用实例调用类的数据属性Star：%s' % Persion.star)
print('并非使用实例调用类的函数属性Learn：%s' % Persion.learn('test','python'))
```
###### 输出内容：
```text
并非使用实例调用类的数据属性Star：earth
并非使用实例调用类的函数属性Learn：test is learning python
```
这种方式并没有创建实例，而只是获取了Persion类中的star变量的值和执行learn函数而已。我们甚至可以看到类中learn函数的self参数也不在代表实例自己，
而是简单的一个形参而已这是由于类是在程序启动时就编译好的，所以可以直接使用Persion.star语法将star数据属性读出来。<br>
大家可能会问，这种写法有什么意义吗？好像和面向对象开发没有任何的关系。其实有一种和实例配合场景，会使用到这种技巧。比如，我有一个网页的注册接口，
使用类的方式写的，每次一个用户注册，都会起一个实例去进行数据库读写的操作。但当访问量大时，可能会导致注册接口遇到瓶颈。我需要增加一个计数器，
要求，当一共有10个实例创建时。暂停注册，将后续注册的数据缓存一下。如下用代码举例：<br>
如：全局计数器功能，每当没创建一个实例时，计数器增加1。并且这个计数器的数据所有实例，和类自己都能查看。
```python
class Persion:
    star = 'earth'
    count = 0  # 定义一个类的数据属性。同时它也是Persion类的一个全局变量。
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex
        Persion.count += 1  # 每当有__init__函数被执行时，就将Persion类的count变量+1

    def learn(self, lesson):  # 定义类的函数函数
        return ('%s is learning %s' % (self, lesson))

    def eat(self):
        return ('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.learn('Python')  # 调用实例的方法，并付给learn函数一个lesson变量
persion2.learn('Java')  # 调用实例的方法，并付给learn函数一个lesson变量
print('%s count: %s' % (persion1.name, persion1.count))
print('%s count: %s' % (persion2.name, persion2.count))
print('Class count: %s' % Persion.count)
```
###### 输出内容：
```text
Jerry count: 2
Tom count: 2
Class count: 2
```
我们可以看到这时，打印出来的计数器的值都为2。
#### **1. 实例调用类的数据属性**
上一章节，我们为实例创建了独有的实例属性。但类中的数据函数属性我们并没有在实例中发现。那类的数据属性是否在实例中哪？
答案肯定是的。
###### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print('%s star: %s ' % (persion1.name, persion1.star))  # 打印persion1实例的属性
print('%s star: %s' % (persion2.name, persion2.star))  # 打印persion实例的属性
print('Class star: %s' % Persion.star)  # 答应Persion类的属性
# 打印persion1、persion2实例和Persion类中star属性的id。看内存地址是否不一样
print('%s id(star): %s ' % (persion1.name, id(persion1.star)))  # 打印persion1实例的属性
print('%s id(star): %s' % (persion2.name, id(persion2.star)))  # 打印persion实例的属性
print('Class id(star): %s' % id(Persion.star))  # 答应Persion类的属性
```
###### 输出内容：
```text
Jerry star: earth 
Tom star: earth
Class star: earth
Jerry id(star): 140636602176208 
Tom id(star): 140636602176208
Class id(star): 140636602176208
```
我们可以从输出看到类中star数据属性的变量。每个实例都能调用。并且内存空间都是一样的。
#### **2. 实例修改类的数据属性**
有了调用当然可以修改。但大家想一下如果修改了类的数据属性，会发生什么？
###### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.star = 'mars'  # 修改persion1实例的star属性为mars
print('%s star: %s ' % (persion1.name, persion1.star))  # 打印persion1实例的属性
print('%s star: %s' % (persion2.name, persion2.star))  # 打印persion实例的属性
print('Class star: %s' % Persion.star)  # 答应Persion类的属性
# 打印persion1、persion2实例和Persion类中star属性的id。看内存地址是否不一样
print('%s id(star): %s ' % (persion1.name, id(persion1.star)))  # 打印persion1实例的属性
print('%s id(star): %s' % (persion2.name, id(persion2.star)))  # 打印persion实例的属性
print('Class id(star): %s' % id(Persion.star))  # 答应Persion类的属性
```
###### 输出内容：
```text
Jerry star: mars 
Tom star: earth
Class star: earth
Jerry id(star): 140526009104680 
Tom id(star): 140526009103056
Class id(star): 140526009103056
```
我们可以发现，就只有persion1实例自己讲stars属性修改为了“mars”，并且内存空间也进行了修改。<br>
这说明实例并不能直接修改类的数据属性。但会重新为这个实例分配一个新的命名空间。
#### **3. 实例与函数属性的关系——绑定方法**
类的函数属性是绑定给实例的。不同的实例所绑定的函数属性的名称空间地址不同。
###### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print('Class NameSpace: %s' % Persion.learn)  # 打印类的learn函数属性的名称空间
print('%s NameSpace: %s' % (persion1.name, persion1.learn))  # 打印persion1实例的learn函数属性的名称空间
print('%s NameSpace: %s' % (persion2.name, persion2.learn))  # 打印persion2实例的learn函数属性的名称空间
```
###### 输出内容：
```text
Class NameSpace: <function Persion.learn at 0x7f6eee555268>
Jerry NameSpace: <bound method Persion.learn of <__main__.Persion object at 0x7f6eee5629b0>>
Tom NameSpace: <bound method Persion.learn of <__main__.Persion object at 0x7f6eee5629e8>>
```
我们可以看到，类和实例的命名空间完全的不同。并且实例的输出了
“<bound method Persion.learn of <__main__.Persion object at 0x7f6eee5629b0>>"
表明自己的内存空间是绑定到Persion类的learn函数属性。
#### **4.实例调用类的函数属性**
哪实例如何调用类的函数属性？
###### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('%s is learning' % self.name)

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.learn()  # 调用实例的方法
persion2.learn()  # 调用实例的方法
```
###### 输出部分：
```text
Jerry is learning
Tom is learning
```
我们只要使用persion1.learn()的方式就可以调用类的函数属性。并创建实例的方法。也就是将persion1这个实例的内存空间作为learn函数的self变量，
传递到learn函数中。

#### **5.实例调用带参数的类函数属性**
哪如果类中learn函数带有其他自己独有的参数呢？
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        print('%s is learning "%s"' % (self.name, lesson))

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.learn('Python')  # 调用实例的方法，并付给learn函数一个lesson变量
persion2.learn('Java')  # 调用实例的方法，并付给learn函数一个lesson变量
```
###### 输出内容
```text
Jerry is learning "Python"
Tom is learning "Java"
```
我们可以看到，通过使用persion1.learn('Python')方法就可以将learn函数中独有的变量传导进去。
## ** 第六章：实例属性的查找顺序
#### ** 1. 属性的操作顺序
我们在如上章节讲了类的属性，创建实例和使用实例的属性和方法。那现在我们来看一下，实例查找属性的先后顺序。
####### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        print('%s is learning "%s"' % (self.name, lesson))

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print(persion1.__dict__)  # 实例自己的属性
print(persion2.__dict__)  # 实例自己的属性
```
###### 输出部分：
```text
{'name': 'Jerry', 'age': 28, 'sex': 'man'}
{'name': 'Tom', 'age': 28, 'sex': 'man'}
```
我们首先可以看到实例有自己的独有属性。这些属性怎么来的哪？是类中定义的__init__函数给传递进去的。所以当类没有__init__函数时，
实例默认也没有任何属性。<br>
那么大家可能有个问题。不是之前可以使用persion1.star()调用类的数据属性,不是使用persion1.learn()调用类的函数属性吗？
是的，但是这些属性。并没有存在实例的名称空间中。而是实例向自己的类进行查找而获得来的。如：<br>
###### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        print('%s is learning "%s"' % (self.name, lesson))

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print(persion1.__dict__)  # 实例自己的属性
print(persion2.__dict__)  # 实例自己的属性
print(persion1.star)  # 实例到自己的类中进行查找，找到了star属性
print(persion2.star)  # 实例到自己的类中进行查找，找到了star属性
```
###### 输出内容：
```text
{'name': 'Jerry', 'age': 28, 'sex': 'man'}
{'name': 'Tom', 'age': 28, 'sex': 'man'}
earth
earth
```
如何去理解哪。实例首先在自己的名字空间中炒作star属性。发现没有？然后定位到自己的类是Persion，然后查找类的名字空间，发现了star属性。
最后将这个star属性直接调用出来。
#### ** 2.总结
1. 首先创建实例时，如果类中有__init__函数就会创建实例自己的属性。当调用实例属性时，如发现实例属性中已有。先调用实例属性。
2. 如果实例属性中没有。就向自己的类中进行查找。类中有的话，就调用类的属性。
3. 如果类也没有，报错退出。

## **第七章：对象之间的交互**
如上章节我们都是创建了不同的实例，但是实例与实例之间并没有任何的交互。本章我们来讲解一下实例之间的交互。<br>
引出一个例子：中美两个公司的之间相互转账。
```python
class Baidu:  # 创建了一个Baidu类
    company = 'BAIDU'  # 创建了一个数据属性，百度
    def __init__(self,card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount


    def transaction(self, another):  # 类的函数，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款

class Ibm:  # 同样创建一个Ibm类
    company = 'IBM'  # 创建了一个数据属性，百度
    def __init__(self, card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount

    def transaction(self, another):  # 类的函数属性，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款


baidu = Baidu('123456', 23, 10)  # 使用中国类创建一个百度的实例
ibm = Ibm('654321', 13, 10)  # 使用美国类创建一个ibm的实例
baidu.transaction(ibm)  # 百度转账给ibm
print('BAIDU card [%s] persent balance: %s'% (baidu.card,baidu.balance))  # 答应百度的当前银行卡余额
print('IBM card [%s] persent balance: %s'% (ibm.card,ibm.balance))  # 答应ibm的当前银行卡余额
```
###### 输出结果：
```text
BAIDU card [123456] persent balance: 13
IBM card [654321] persent balance: 23
```
我们看到通过在类的 def transaction(self, another)函数属性中增加一个形参（another），它的实参就是另一个实例。
这种方式就实现的实例之间的交互，一个实例触发的方法会对其他实例产生联动性
## **第八章：补充知识**
1. 站的角度不同，定义出的类截然不同
2. 现实中的类并不一定等于程序中的类，比如现实中的公司类，现实拆分为业务、部门类
3. 有时编程需要，程序可以定义现实中不存在的类。如：策略类。


## ** 第九章： 继承**
继承指的是类与类之间的关系，在python中，新建的类可以继承一个或多个父类，父类也可以称为基类或超类
，新建的类称为派生类或子类。子类与父类之间是is的关系，父类有的属性和方法，子类中也都可以使用。
继承的功能之一用来解决代码的重用性。
#### ** 1.继承的语法**
```python
class ParentClass1:  # 父类
    pass

class ParentClass2:  # 父类
    pass

class SubClass1(ParentClass1):  # 子类继承ParentClass1父类
    pass

class SubClass2(ParentClass1,ParentClass2):  # 子类继承ParentClass1,ParentClass2父类
    pass
```
#### **2. 查询类的继承关系**
我们如何去查找某个类是否有自己的继承关系哪？
###### 代码部分：
```python
class ParentClass1:  # 父类
    pass

class ParentClass2:  # 父类
    pass

class SubClass1(ParentClass1):  # 子类继承ParentClass1父类
    pass

class SubClass2(ParentClass1,ParentClass2):  # 子类继承ParentClass1,ParentClass2父类
    pass

print(SubClass1.__bases__)  # 查看SubClass1类的父类
print(SubClass2.__bases__)  # 查看SubClass2类的父类
```
###### 输出部分：
```text
(<class '__main__.ParentClass1'>,)
(<class '__main__.ParentClass1'>, <class '__main__.ParentClass2'>)
```

#### ** 3. 子类与父类的关系
我们之前提到了子类和父类是is的关系。怎么去理解这句话，我们用“对象之间的交互”章节中的代码来讲解一下：
```python
class Baidu:  # 创建了一个Baidu类
    company = 'BAIDU'  # 创建了一个数据属性，百度
    def __init__(self,card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount


    def transaction(self, another):  # 类的函数，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款

class Ibm:  # 同样创建一个Ibm类
    company = 'IBM'  # 创建了一个数据属性，百度
    def __init__(self, card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount

    def transaction(self, another):  # 类的函数属性，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款


baidu = Baidu('123456', 23, 10)  # 使用中国类创建一个百度的实例
ibm = Ibm('654321', 13, 10)  # 使用美国类创建一个ibm的实例
baidu.transaction(ibm)  # 百度转账给ibm
print('BAIDU card [%s] persent balance: %s'% (baidu.card,baidu.balance))  # 答应百度的当前银行卡余额
print('IBM card [%s] persent balance: %s'% (ibm.card,ibm.balance))  # 答应ibm的当前银行卡余额
```
如上的代码，我们创建了2个公司的类，一个是Baidu，另一个是Ibm。那么他们是否可以有一个父类。当然可以！我们定义一个Company的类，
那么这个Company的类也有自己的构建函数和transaction的函数属性哪？必然是可以的。修改代码如下：
###### 代码部分：
```python
class Company:  # 父类
    def __init__(self,card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount


    def transaction(self, another):  # 类的函数，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款


class Baidu(Company):  # Baidu类继承Company父类
    name = 'BAIDU'  # 创建了一个数据属性，百度


class Ibm(Company):  # Ibm类继承Company父类
    name = 'IBM'  # 创建了一个数据属性，百度



baidu = Baidu('123456', 23, 10)  # 使用中国类创建一个百度的实例
ibm = Ibm('654321', 13, 10)  # 使用美国类创建一个ibm的实例
baidu.transaction(ibm)  # 百度转账给ibm
print('BAIDU card [%s] persent balance: %s'% (baidu.card,baidu.balance))  # 打印百度的当前银行卡余额
print('IBM card [%s] persent balance: %s'% (ibm.card,ibm.balance))  # 打印ibm的当前银行卡余额
```
###### 输出部分：
```text
BAIDU card [123456] persent balance: 13
IBM card [654321] persent balance: 23
```
我们可以发现Baidu、IBM类并没有定义构建函数和函数属性。但是程序还是照样运行正常。这就说明了，父类中定义的所有东西，如果子类中没有定义相同的内容的化。子类就会默认调用父类中的所有的属性。

#### **4.继承中实例属性的查找先后顺序
我们知道普通类中，实例属性的查找先后顺序如下：
1. 首先创建实例时，如果类中有__init__函数就会创建实例自己的属性。当调用实例属性时，如发现实例属性中已有。先调用实例属性。
2. 如果实例属性中没有。就向自己的类中进行查找。类中有的话，就调用类的属性。
3. 如果类也没有，报错退出。
但在继承类中哪？查找顺序如下：
1. 首先创建实例时，会在自己类中查找是否有__init__函数。有的话，就会创建实例自己的属性，但是如果自己类中没有__init__函数，就会从自己的父类中取查找__init__函数，
如果父类有的话，就继承父类的__init__函数，创建实例自己的属性。当父类也没有的话，实例就不带任何属性。
2. 如果实例属性中没有。就向自己的类中进行查找。类中有的话，就调用类的属性。如果自己类中没有，就向父类中查找，类中有的话，就调用父类的属性
3. 如果父类也没有，报错退出。
但是我们看一下如下这个代码：
##### 代码部分：
```python
class Company:  # 父类
    def transaction(self):  # 类的函数，转账
        print("Transaction monry to your Comany")
        self.purchase()  # 调用实例的采购函数。等于：badiu.purchase


    def purchase(self):  # 类的函数，采购
        print("Your Comany can purchase something.")


class Baidu(Company):  # Baidu类继承Company父类
    def purchase(self):  # 派生一个自己的采购函数
        print("My Comany can purchase Phone.")

baidu = Baidu()  # 使用中国类创建一个百度的实例
baidu.transaction()
```
###### 输出内容：
```text
Transaction monry to your Comany
My Comany can purchase Phone.
```
我们来看一下输出的内容。
- 第一行的“Transaction monry to your Comany”很好理解。当实例调用transcation时，它去查找自己的属性。
发现自己的实例属性中并没有transcation这个属性，所以到Baidu类中取查找，也发现没有。就到父类company中去查找，找到后就打印出结果（这就是类的继承）。
- 然后发现父类company在transcation属性中还有一段self.purchase()代码。程序会将自己的实例baidu作为self的实参传递给transcation属性。所以self.purchase()代码就等同于
baidu.purchase()。这时baidu实例又触发了一次查找动作。先从自己的实例中查找属性，没有找到。然后在自己的baidu类中查找到了purchase属性。
最后打印出“My Comany can purchase Phone”，而非父类company的“Your Comany can purchase something.”


## ** 第十章：派生**
派生就是子类在继承父类的基础上衍生出新的属性。子类中独有的，父类中没有的；或子类定义与父类重名的东西。子类也叫派生类。
###### 代码部分：
```python
class Company:  # 父类
    name = 'Company' # 父类的name数据属性
    def transaction(self):  # 类的函数属性，转账
        print("Transaction monry to your Comany")
        self.purchase()  # 调用实例的采购函数


    def purchase(self):  # 类的函数属性，采购
        print("Your Comany can purchase something.")


class Baidu(Company):  # Baidu类继承Company父类
    name = 'Baidu'  # 派生一个自己的数据属性
    def purchase(self):  # 派生一个自己的采购函数属性
        print("My Comany can purchase Phone.")

    def website(self):  # 派生一个自己专用的website函数属性。父中没有
        print("www.badiu.com")
```
## ** 第十一章：继承实现原理 **
#### ** 1. 继承的查找原则
python对于定义的每一个类，都会计算出一个方法解析顺序（MPO）列表，这个MPO雷彪就是一个简单的所有积累的线性顺序列表，
使用mro属性可以查看这个列表：
```text
>>>> Baidu.mro()  # 等同于Baidu.__mro__
[<class '__main__.Baidu'>, <class '__main__.Company'>, <class 'object'>]
```
为了实现继承python会在MRO列表上从左到右查找基类，直到找到第一个匹配的属性为止，而这个MRO列表的构造是通过一个C3线性化
算法来实现的。我们不去深究这个算法的原理，它实际上是合并所有父类的MRO列表并遵循如下原则：
1. 子类会先于父类查找。
2. 多个父类会根据他们在列表中的顺序被查找。
3. 如果有多个类存在相同的属性，使用第一个属性。
#### ** 2. 继承的查询类型
上面的讲了一个类的查询原则，是依据MRO列表从左到右查找自己的父类。但程序中的类与类之间存在了多种继承的关系，
也就是说，一个父类也可能是其他父类的一个子类。那么一个python中如何最终定位到父类哪？在将这个问题前，我们先引出
python中对类的两个分类的定义与他们的查找方式：<br>
1. 经典类：没有继承object的类，以及他的子类称为经典类，只有在python2中有这个概念。如何去理解。
> 经典类的语法：
> ```python
> class Foo:
>     pass
> class Bar(Foo):
>     pass
> ```
2. 新式类：继承object的类，以及他的子类称为经典类。python3中所有类都是新式类。
> 新式类的语法：
> ```python
> class Foo:
>     pass
> class Bar(Foo):
>     pass
> ```
#### ** 3.深度优先查找与广度优先查找
经典类继承查找的先后顺序按照深度优先的方式查找。如何去理解。请看下图
![avatar](https://github.com/henryyuan/first-app/blob/master/homework/Module3/Study_Note/%E7%BB%A7%E6%89%BF%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%9F%A5%E8%AF%A2.png)

新式类继承查找的先后顺序按照广度优先的方式查找如何去理解。请看下图
