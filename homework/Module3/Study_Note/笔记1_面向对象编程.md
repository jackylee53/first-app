## **第一章：面向对象编程与面向过程编程**
#### **1.面向过程编程**
面向过程的编程，就是将一个大的任务拆分成多个小任务。完成了所有的小任务，也就完成了整个任务
###### 优点:
1. 将负责的问题流程化，进而简单化。
2. 运行速度快
###### 缺点：
1. 扩展性非常差。当需要增加代码时，就捉襟见肘，需要修改多处。
###### 使用方法:
- 适合用于一些简单的自动化，监控脚本中。

#### **2.面向对象编程**
我们可能之前听说过“python一起都对象”的说法。
在面向对象编程之前，需要了解什么是对象？
我们可以这样理解，对象是可以对其做事情的一些东西。这个对象有一定的特征和技能，可以处理你要求它做的事情。
###### 优点:
1. 可扩展性强。
###### 缺点：
1. 编程复杂度高。
###### 使用方法:
- 适合用于一些简单的自动化，监控脚本中。
## **第二章：如何使用面向对象编写程序**
#### **1.概述**
首先我们看一下面向对象编程中牵涉到一些概念。
面向对象技术简介
- 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
(打个比方：如Henry，Tom是两个人，无论Henry和Tom他们个体都是是属于一个对象。那么它的类就是——人类。Henry、Tom共有的属性，比如他们有年龄，名字，工作、等。
Henry、Tom共有的方法，比如：说话，吃饭，走路，等)
- 类的属性：类的属性包含两个属性(数据属性、函数属性)：
> - 数据属性：类中定义的变量。类变量概念如下：
>>> - 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
> - 函数属性：类中定义的函数。（函数属性，也可以理解为是实例的方法）
- 实例化：创建一个类的实例，类的具体对象。（打个比方：我们使用人类这个类定义Jerry。那么Jerry就是人类这个类的一个实例化出来的对象）
- 实例变量：定义在类中__init__函数属性中的变量，只作用于当前实例的变量。
- 实例：使用类创建的一个个对象，包含类变量、实例变量、和类的函数变量。(打个比方：Jerry就是用人类这个类，
最后生成的实例)。实例还包含两个内容（属性和方法）：
> - 属性：类变量和实例变量都是对象的属性。
> - 方法：类的函数属性就是对象的方法。
- 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。
- 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
- 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。


- 对象：通过类定义的数据结构实例化而得的就是对象。对象包括两个数据成员（类变量和实例变量）和方法。
## ** 第三章：类的使用**
#### **1.定义类**
###### ** 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def learn(self):  # 定义类的函数属性
        print('learning')

    def eat(self):
        print('eating')
```


#### **3. 使用类——实例化对象**
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def learn(self):  # 定义类的函数方法
        print('learning')

    def eat(self):
        print('eating')
        
persion1 = Persion()  # 创建实例化对象persion1
```
使用persion1 = Persion()语句。就使用了Persion类实例化了一个persion1的对象。
#### **4. 类的执行过程**
类会在定义阶段就执行内部的代码，并放入名称空间。与函数不同，函数只是在调用时才会执行。
#### **5. 调用类的数据属性**
调用类的数据属性方法：
###### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def learn(self):  # 定义类的函数属性
        print('learning')

    def eat(self):
        print('eating')

stu_star = Persion.star  # 调用类的数据属性
print(stu_star)
```
###### 输出内容：
```text
earth
```
#### **6. 增加类的数据属性**
增加类的数据属性方法：
###### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

Persion.country = 'china'  # 增加的数据属性
print(Persion.__dict__)
```
###### 输出内容：
```text
{'__module__': '__main__', 'star': 'earth', 'learn': <function Persion.learn at 0x7f8b36d1a158>, 'eat': <function Persion.eat at 0x7f8b36d1a1e0>,
 '__dict__': <attribute '__dict__' of 'Persion' objects>, '__weakref__': <attribute '__weakref__' of 'Persion' objects>, '__doc__': None, 'country': 'china'}
```
#### **7.删除类的数据属性**
删除类的数据属性方法：
###### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

del Persion.star  # 删除类的数据属性
print(Persion.__dict__)
```
###### 输出内容：
```text
{'__module__': '__main__', 'learn': <function Persion.learn at 0x7f0c21f17158>, 'eat': <function Persion.eat at 0x7f0c21f171e0>, '__dict__': <attribute '__dict__' of 'Persion' objects>, 
'__weakref__': <attribute '__weakref__' of 'Persion' objects>, '__doc__': None}
```

#### ** 8.修改类的数据属性**
修改类的属性方法如下：
###### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

Persion.star = 'mars'  # 修改类的数据属性
print(Persion.__dict__)
```
###### 输出内容：
```text
{'__module__': '__main__', 'star': 'mars', 'learn': <function Persion.learn at 0x7ff494004158>, 'eat': <function Persion.eat at 0x7ff4940041e0>, 
'__dict__': <attribute '__dict__' of 'Persion' objects>, '__weakref__': <attribute '__weakref__' of 'Persion' objects>, '__doc__': None}
```
#### ** 9. 类的特殊属性**


## **第四章：对象的使用**
#### ** 1. 构造函数——__init__()**
我们先看一下如下的代码
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

persion1 = Persion()
```
我们定义了一个人类的类，创建了一个star的数据属性和2个learn、eat的函数属性（方法）。
并实例化了第一个人类的对象persion1。但是这时，可能你会发现Persion1这个对象，
并不止有star这个属性，他还有name、age、sex等属性。那我们应该怎么在类中定义一些可变的属性呢？这里引出__init__函数属性。
由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。
通过定义一个特殊的__init__方法，在创建实例的时候，就把可变的属性绑上去。修改代码如下：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
print(persion1.__dict__)
persion2 = Persion('Tom',20, 'man')  # 创建类的实例对象“TOM”
print(persion2.__dict__)
```
###### 输出内容：
```text
{'name': 'Jerry', 'age': 28, 'sex': 'man'}
{'name': 'Tom', 'age': 20, 'sex': 'man'}
```
我们可以看到，这时在创建类的实例对象时。需要向类导入四个实例变量。“self, name, age, sex”。
通过创建实例时，实例变量的导入。就可以为不同的实例创建不同的属性了。
#### ** 2.self概念**
大家看到如上代码中类的函数属性的形参都会自动加上一个“self”产生疑问。这个self是什么？<br>
- self：是个对象（Object），是当前类的实例自己。

因此，对应的self.name = name这段代码含义。就是为实例persion1创建一个name变量，
并且使用创建实例时倒入的name变量就行赋值。（可查阅上面章节的“调用类的数据属性”）
#### ** 3.实例化过程**
我们具体来讲一下如上代码的实例化过程：
1. 首先persion1实例会像内存申请一个空的内存空间，命名为persion1。
2. 其次persion1实例将自己的命名空间和其他需要传导的实例属性传递给Persion类。
3. 类中的__init__(self, name, age, sex)构建函数，
获取persion1实例的名字空间（self）和其他参数（name, age, sex），进行函数内部的处理。
4. self.name = name在persion1实例的名字空间中创建一个新的name变量，并用传导进入的实参进行赋值
5. 将处理后的结果返回给persion1的名称空间

#### ** 4.调用实例的实例属性**
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
print('Name: %s' % persion1.name)  # 打印实例属性

```
###### 输出内容：
```text
Name: Jerry
Star: earth
```
#### ** 5.增加实例的实例属性**
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion1.phone = '12345678910'  # 添加实例属性
print('Phone: %s' % persion1.phone)  # 打印增加的属性
```
###### 输出内容：
```text
Phone: 12345678910
```
#### ** 6.删除实例的实例属性**
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion1.phone = '12345678910'  # 添加实例属性
print('Phone: %s' % persion1.phone)  # 打印增加的属性
del persion1.phone  # 删除phone实例属性
print('Phone: %s' % persion1.phone)  # 再次打印报错
```
###### 输出内容：
```text
Phone: 12345678910
Traceback (most recent call last):
  File "/development/homework/test.py", line 19, in <module>
    print('Phone: %s' % persion1.phone)  # 再次打印报错
AttributeError: 'Persion' object has no attribute 'phone'
```
#### ** 7.修改实例的实例属性**
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion1.age = 48  # 修改age的实例属性
print('Age: %s' % persion1.age)  # 打印修改后的age
```
###### 输出内容：
```text
Age: 48
```
## **第五章：实例属性查找与绑定方法**
#### **1直接调用类是否可行？**
在开始讲实例调用类属性方法之前。现有一个问题，那就是python是否直接可以去调用类中的数据属性和函数属性。当然是可以的？
###### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性

    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量
        # Persion.count += 1

    def learn(self, lesson):  # 定义类的函数函数
        return ('%s is learning %s' % (self, lesson))

    def eat(self):
        return ('%s is eating' % self.name)

print('并非使用实例调用类的数据属性Star：%s' % Persion.star)
print('并非使用实例调用类的函数属性Learn：%s' % Persion.learn('test','python'))
```
###### 输出内容：
```text
并非使用实例调用类的数据属性Star：earth
并非使用实例调用类的函数属性Learn：test is learning python
```
这种方式并没有创建实例，而只是获取了Persion类中的star变量的值和执行learn函数而已。我们甚至可以看到类中learn函数的self参数也不在代表实例自己，
而是简单的一个形参而已这是由于类是在程序启动时就编译好的，所以可以直接使用Persion.star语法将star数据属性读出来。<br>
大家可能会问，这种写法有什么意义吗？好像和面向对象开发没有任何的关系。其实有一种和实例配合场景，会使用到这种技巧。比如，我有一个网页的注册接口，
使用类的方式写的，每次一个用户注册，都会起一个实例去进行数据库读写的操作。但当访问量大时，可能会导致注册接口遇到瓶颈。我需要增加一个计数器，
要求，当一共有10个实例创建时。暂停注册，将后续注册的数据缓存一下。如下用代码举例：<br>
如：全局计数器功能，每当没创建一个实例时，计数器增加1。并且这个计数器的数据所有实例，和类自己都能查看。
```python
class Persion:
    star = 'earth'
    count = 0  # 定义一个类的数据属性。同时它也是Persion类的一个全局变量。
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex
        Persion.count += 1  # 每当有__init__函数被执行时，就将Persion类的count变量+1

    def learn(self, lesson):  # 定义类的函数函数
        return ('%s is learning %s' % (self, lesson))

    def eat(self):
        return ('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.learn('Python')  # 调用实例的方法，并付给learn函数一个lesson变量
persion2.learn('Java')  # 调用实例的方法，并付给learn函数一个lesson变量
print('%s count: %s' % (persion1.name, persion1.count))
print('%s count: %s' % (persion2.name, persion2.count))
print('Class count: %s' % Persion.count)
```
###### 输出内容：
```text
Jerry count: 2
Tom count: 2
Class count: 2
```
我们可以看到这时，打印出来的计数器的值都为2。
#### **1. 实例调用类的数据属性**
上一章节，我们为实例创建了独有的实例属性。但类中的数据函数属性我们并没有在实例中发现。那类的数据属性是否在实例中哪？
答案肯定是的。
###### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print('%s star: %s ' % (persion1.name, persion1.star))  # 打印persion1实例的属性
print('%s star: %s' % (persion2.name, persion2.star))  # 打印persion实例的属性
print('Class star: %s' % Persion.star)  # 答应Persion类的属性
# 打印persion1、persion2实例和Persion类中star属性的id。看内存地址是否不一样
print('%s id(star): %s ' % (persion1.name, id(persion1.star)))  # 打印persion1实例的属性
print('%s id(star): %s' % (persion2.name, id(persion2.star)))  # 打印persion实例的属性
print('Class id(star): %s' % id(Persion.star))  # 答应Persion类的属性
```
###### 输出内容：
```text
Jerry star: earth 
Tom star: earth
Class star: earth
Jerry id(star): 140636602176208 
Tom id(star): 140636602176208
Class id(star): 140636602176208
```
我们可以从输出看到类中star数据属性的变量。每个实例都能调用。并且内存空间都是一样的。
#### **2. 实例修改类的数据属性**
有了调用当然可以修改。但大家想一下如果修改了类的数据属性，会发生什么？
###### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.star = 'mars'  # 修改persion1实例的star属性为mars
print('%s star: %s ' % (persion1.name, persion1.star))  # 打印persion1实例的属性
print('%s star: %s' % (persion2.name, persion2.star))  # 打印persion实例的属性
print('Class star: %s' % Persion.star)  # 答应Persion类的属性
# 打印persion1、persion2实例和Persion类中star属性的id。看内存地址是否不一样
print('%s id(star): %s ' % (persion1.name, id(persion1.star)))  # 打印persion1实例的属性
print('%s id(star): %s' % (persion2.name, id(persion2.star)))  # 打印persion实例的属性
print('Class id(star): %s' % id(Persion.star))  # 答应Persion类的属性
```
###### 输出内容：
```text
Jerry star: mars 
Tom star: earth
Class star: earth
Jerry id(star): 140526009104680 
Tom id(star): 140526009103056
Class id(star): 140526009103056
```
我们可以发现，就只有persion1实例自己讲stars属性修改为了“mars”，并且内存空间也进行了修改。<br>
这说明实例并不能直接修改类的数据属性。但会重新为这个实例分配一个新的命名空间。
#### **3. 实例与函数属性的关系——绑定方法**
类的函数属性是绑定给实例的。不同的实例所绑定的函数属性的名称空间地址不同。
###### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print('Class NameSpace: %s' % Persion.learn)  # 打印类的learn函数属性的名称空间
print('%s NameSpace: %s' % (persion1.name, persion1.learn))  # 打印persion1实例的learn函数属性的名称空间
print('%s NameSpace: %s' % (persion2.name, persion2.learn))  # 打印persion2实例的learn函数属性的名称空间
```
###### 输出内容：
```text
Class NameSpace: <function Persion.learn at 0x7f6eee555268>
Jerry NameSpace: <bound method Persion.learn of <__main__.Persion object at 0x7f6eee5629b0>>
Tom NameSpace: <bound method Persion.learn of <__main__.Persion object at 0x7f6eee5629e8>>
```
我们可以看到，类和实例的命名空间完全的不同。并且实例的输出了
“<bound method Persion.learn of <__main__.Persion object at 0x7f6eee5629b0>>"
表明自己的内存空间是绑定到Persion类的learn函数属性。
#### **4.实例调用类的函数属性**
哪实例如何调用类的函数属性？
###### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('%s is learning' % self.name)

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.learn()  # 调用实例的方法
persion2.learn()  # 调用实例的方法
```
###### 输出部分：
```text
Jerry is learning
Tom is learning
```
我们只要使用persion1.learn()的方式就可以调用类的函数属性。并创建实例的方法。也就是将persion1这个实例的内存空间作为learn函数的self变量，
传递到learn函数中。

#### 5.实例调用带参数的类函数属性**
哪如果类中learn函数带有其他自己独有的参数呢？
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        print('%s is learning "%s"' % (self.name, lesson))

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.learn('Python')  # 调用实例的方法，并付给learn函数一个lesson变量
persion2.learn('Java')  # 调用实例的方法，并付给learn函数一个lesson变量
```
###### 输出内容
```text
Jerry is learning "Python"
Tom is learning "Java"
```
我们可以看到，通过使用persion1.learn('Python')方法就可以将learn函数中独有的变量传导进去。
## **第七章：对象之间的交互**
如上章节我们都是创建了不同的实例，但是实例与实例之间并没有任何的交互。本章我们来讲解一下实例之间的交互。<br>
引出一个例子：模拟游戏，将多个职业作为类，每个类有不同的英雄。不同的用户可以初始化1个英雄实例，并制定自己的昵称
，生命值，攻击力。并相互伤害。
```python

```
## **第六章：补充知识**
1. 站的角度不同，定义出的类截然不同
2. 现实中的类并不一定等于程序中的类，比如现实中的公司类，现实拆分为业务、部门类
3. 有时编程需要，程序可以定义现实中不存在的类。如：策略类。
 
## 类属性的查找顺序

