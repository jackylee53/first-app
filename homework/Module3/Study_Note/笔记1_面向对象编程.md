# **第一章：面向对象编程与面向过程编程** 
## **1.面向过程编程**
&emsp;&emsp;面向过程的编程，就是将一个大的任务拆分成多个小任务。完成了所有的小任务，也就完成了整个任务
### 优点:
1. 将负责的问题流程化，进而简单化。
2. 运行速度快
### 缺点：
1. 扩展性非常差。当需要增加代码时，就捉襟见肘，需要修改多处。
### 使用方法:
- 适合用于一些简单的自动化，监控脚本中。

## **2.面向对象编程**
我们可能之前听说过“python一起都对象”的说法。
在面向对象编程之前，需要了解什么是对象？
我们可以这样理解，对象是可以对其做事情的一些东西。这个对象有一定的特征和技能，可以处理你要求它做的事情。
### 优点:
1. 可扩展性强。
### 缺点：
1. 编程复杂度高。
### 使用方法:
- 适合用于一些复杂的程序系统，如：游戏、公司的各种管理系统、等。
# **第二章：如何使用面向对象编写程序**
## **1.概述**
首先我们看一下面向对象编程中牵涉到一些概念。
面向对象技术简介
- 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
(打个比方：如Henry，Tom是两个人，无论Henry和Tom他们个体都是是属于一个对象。那么它的类就是——人类。Henry、Tom共有的属性，比如他们有年龄，名字，工作、等。
Henry、Tom共有的方法，比如：说话，吃饭，走路，等)
- 类的属性：类的属性包含两个属性(数据属性、函数属性)：
> - 数据属性：类中定义的变量。类变量概念如下：
>>> - 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
> - 函数属性：类中定义的函数。（函数属性，也可以理解为是实例的方法）
- 实例化：创建一个类的实例，类的具体对象。（打个比方：我们使用人类这个类定义Jerry。那么Jerry就是人类这个类的一个实例化出来的对象）
- 实例变量：定义在类中__init__函数属性中的变量，只作用于当前实例的变量，也是当前实例自己独有的属性。
- 实例：使用类创建的一个个对象，包含类变量、实例变量、和类的函数变量。(打个比方：Jerry就是用人类这个类，
最后生成的实例)。实例还包含两个内容（属性和方法）：
> - 属性：类变量和实例变量都是对象的属性。
> - 方法：类的函数属性就是对象的方法。
- 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。
- 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
- 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。
- 对象：通过类定义的数据结构实例化而得的就是对象。对象包括两个数据成员（类变量和实例变量）和方法。
# ** 第三章：类的使用**
## **1.定义类**
#### ** 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def learn(self):  # 定义类的函数属性
        print('learning')

    def eat(self):
        print('eating')
```


## **2. 使用类——实例化对象**
#### ** 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def learn(self):  # 定义类的函数方法
        print('learning')

    def eat(self):
        print('eating')
        
persion1 = Persion()  # 创建实例化对象persion1
```
使用persion1 = Persion()语句。就使用了Persion类实例化了一个persion1的对象。
## **4. 类的执行过程**
类会在定义阶段就执行内部的代码，并放入名称空间。与函数不同，函数只是在调用时才会执行。
## **5. 调用类的数据属性**
调用类的数据属性方法：
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def learn(self):  # 定义类的函数属性
        print('learning')

    def eat(self):
        print('eating')

stu_star = Persion.star  # 调用类的数据属性
print(stu_star)
```
#### 输出内容：
```text
earth
```
## **6. 增加类的数据属性**
增加类的数据属性方法：
###### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

Persion.country = 'china'  # 增加的数据属性
print(Persion.__dict__)
```
###### 输出内容：
```text
{'__module__': '__main__', 'star': 'earth', 'learn': <function Persion.learn at 0x7f8b36d1a158>, 'eat': <function Persion.eat at 0x7f8b36d1a1e0>,
 '__dict__': <attribute '__dict__' of 'Persion' objects>, '__weakref__': <attribute '__weakref__' of 'Persion' objects>, '__doc__': None, 'country': 'china'}
```
## **7.删除类的数据属性**
删除类的数据属性方法：
#### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

del Persion.star  # 删除类的数据属性
print(Persion.__dict__)
```
#### 输出内容：
```text
{'__module__': '__main__', 'learn': <function Persion.learn at 0x7f0c21f17158>, 'eat': <function Persion.eat at 0x7f0c21f171e0>, '__dict__': <attribute '__dict__' of 'Persion' objects>, 
'__weakref__': <attribute '__weakref__' of 'Persion' objects>, '__doc__': None}
```

## ** 8.修改类的数据属性**
修改类的属性方法如下：
#### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

Persion.star = 'mars'  # 修改类的数据属性
print(Persion.__dict__)
```
#### 输出内容：
```text
{'__module__': '__main__', 'star': 'mars', 'learn': <function Persion.learn at 0x7ff494004158>, 'eat': <function Persion.eat at 0x7ff4940041e0>, 
'__dict__': <attribute '__dict__' of 'Persion' objects>, '__weakref__': <attribute '__weakref__' of 'Persion' objects>, '__doc__': None}
```
## ** 9. 类的特殊属性**
类中除了数据属性和函数属性，还有一些自己的特殊属性。
```text
C.__name__：类的名字（字符串）
C.__doc__：类的文档字符串
C.__bases__：类的所有父类构成的元组
C.__dict__：类的所有属性
C.__module__：类定义所在的模块
C.__class__：实例所对应的类
```

# **第四章：对象的使用**
## ** 1. 构造函数——__init__()**
我们先看一下如下的代码
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的属性
    def learn(self):  # 定义类的方法
        print('learning')

    def eat(self):
        print('eating')

persion1 = Persion()
```
我们定义了一个人类的类，创建了一个star的数据属性和2个learn、eat的函数属性（方法）。
并实例化了第一个人类的对象persion1。但是这时，可能你会发现Persion1这个对象，
并不止有star这个属性，他还有name、age、sex等属性。那我们应该怎么在类中定义一些可变的属性呢？这里引出__init__函数属性。
由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。
通过定义一个特殊的__init__方法，在创建实例的时候，就把可变的属性绑上去。修改代码如下：
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
print(persion1.__dict__)
persion2 = Persion('Tom',20, 'man')  # 创建类的实例对象“TOM”
print(persion2.__dict__)
```
#### 输出内容：
```text
{'name': 'Jerry', 'age': 28, 'sex': 'man'}
{'name': 'Tom', 'age': 20, 'sex': 'man'}
```
我们可以看到，这时在创建类的实例对象时。需要向类导入四个实例变量。“self, name, age, sex”。
通过创建实例时，实例变量的导入。就可以为不同的实例创建不同的属性了。
## ** 2.self概念**
大家看到如上代码中类的函数属性的形参都会自动加上一个“self”产生疑问。这个self是什么？<br>
- self：是个对象（Object），是当前类的实例自己。

因此，对应的self.name = name这段代码含义。就是为实例persion1创建一个name变量，
并且使用创建实例时倒入的name变量就行赋值。（可查阅上面章节的“调用类的数据属性”）
## ** 3.实例化过程**
我们具体来讲一下如上代码的实例化过程：
1. 首先persion1实例会像内存申请一个空的内存空间，命名为persion1。
2. 其次persion1实例将自己的命名空间和其他需要传导的实例属性传递给Persion类。
3. 类中的__init__(self, name, age, sex)构建函数，
获取persion1实例的名字空间（self）和其他参数（name, age, sex），进行函数内部的处理。
4. self.name = name在persion1实例的名字空间中创建一个新的name变量，并用传导进入的实参进行赋值
5. 将处理后的结果返回给persion1的名称空间

## ** 4.调用实例的实例属性**
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
print('Name: %s' % persion1.name)  # 打印实例属性

```
#### 输出内容：
```text
Name: Jerry
Star: earth
```
## ** 5.增加实例的实例属性**
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion1.phone = '12345678910'  # 添加实例属性
print('Phone: %s' % persion1.phone)  # 打印增加的属性
```
#### 输出内容：
```text
Phone: 12345678910
```
## ** 6.删除实例的实例属性**
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion1.phone = '12345678910'  # 添加实例属性
print('Phone: %s' % persion1.phone)  # 打印增加的属性
del persion1.phone  # 删除phone实例属性
print('Phone: %s' % persion1.phone)  # 再次打印报错
```
#### 输出内容：
```text
Phone: 12345678910
Traceback (most recent call last):
  File "/development/homework/test.py", line 19, in <module>
    print('Phone: %s' % persion1.phone)  # 再次打印报错
AttributeError: 'Persion' object has no attribute 'phone'
```
## ** 7.修改实例的实例属性**
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion1.age = 48  # 修改age的实例属性
print('Age: %s' % persion1.age)  # 打印修改后的age
```
#### 输出内容：
```text
Age: 48
```
# **第五章：实例属性的调用与绑定方法**
## **1直接调用类是否可行？**
在开始讲实例调用类属性方法之前。现有一个问题，那就是python是否直接可以去调用类中的数据属性和函数属性。当然是可以的？
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性

    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        return ('%s is learning %s' % (self, lesson))

    def eat(self):
        return ('%s is eating' % self.name)

print('并非使用实例调用类的数据属性Star：%s' % Persion.star)
print('并非使用实例调用类的函数属性Learn：%s' % Persion.learn('test','python'))
```
#### 输出内容：
```text
并非使用实例调用类的数据属性Star：earth
并非使用实例调用类的函数属性Learn：test is learning python
```
这种方式并没有创建实例，而只是获取了Persion类中的star变量的值和执行learn函数而已。我们甚至可以看到类中learn函数的self参数也不在代表实例自己，
而是简单的一个形参而已这是由于类是在程序启动时就编译好的，所以可以直接使用Persion.star语法将star数据属性读出来。<br>
大家可能会问，这种写法有什么意义吗？好像和面向对象开发没有任何的关系。其实有一种和实例配合场景，会使用到这种技巧。比如，我有一个网页的注册接口，
使用类的方式写的，每次一个用户注册，都会起一个实例去进行数据库读写的操作。但当访问量大时，可能会导致注册接口遇到瓶颈。我需要增加一个计数器，
要求，当一共有10个实例创建时。暂停注册，将后续注册的数据缓存一下。如下用代码举例：<br>
如：全局计数器功能，每当没创建一个实例时，计数器增加1。并且这个计数器的数据所有实例，和类自己都能查看。
#### 代码部分：
```python
class Persion:
    star = 'earth'
    count = 0  # 定义一个类的数据属性。同时它也是Persion类的一个全局变量。
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex
        Persion.count += 1  # 每当有__init__函数被执行时，就将Persion类的count变量+1

    def learn(self, lesson):  # 定义类的函数函数
        return ('%s is learning %s' % (self, lesson))

    def eat(self):
        return ('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.learn('Python')  # 调用实例的方法，并付给learn函数一个lesson变量
persion2.learn('Java')  # 调用实例的方法，并付给learn函数一个lesson变量
print('%s count: %s' % (persion1.name, persion1.count))
print('%s count: %s' % (persion2.name, persion2.count))
print('Class count: %s' % Persion.count)
```
#### 输出内容：
```text
Jerry count: 2
Tom count: 2
Class count: 2
```
我们可以看到这时，打印出来的计数器的值都为2。
## **2. 实例调用类的数据属性**
上一章节，我们为实例创建了独有的实例属性。但类中的数据函数属性我们并没有在实例中发现。那类的数据属性是否在实例中哪？
答案肯定是的。
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print('%s star: %s ' % (persion1.name, persion1.star))  # 打印persion1实例的属性
print('%s star: %s' % (persion2.name, persion2.star))  # 打印persion实例的属性
print('Class star: %s' % Persion.star)  # 答应Persion类的属性
# 打印persion1、persion2实例和Persion类中star属性的id。看内存地址是否不一样
print('%s id(star): %s ' % (persion1.name, id(persion1.star)))  # 打印persion1实例的属性
print('%s id(star): %s' % (persion2.name, id(persion2.star)))  # 打印persion实例的属性
print('Class id(star): %s' % id(Persion.star))  # 答应Persion类的属性
```
#### 输出内容：
```text
Jerry star: earth 
Tom star: earth
Class star: earth
Jerry id(star): 140636602176208 
Tom id(star): 140636602176208
Class id(star): 140636602176208
```
我们可以从输出看到类中star数据属性的变量。每个实例都能调用。并且内存空间都是一样的。
## **3. 实例修改类的数据属性**
有了调用当然可以修改。但大家想一下如果修改了类的数据属性，会发生什么？
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.star = 'mars'  # 修改persion1实例的star属性为mars
print('%s star: %s ' % (persion1.name, persion1.star))  # 打印persion1实例的属性
print('%s star: %s' % (persion2.name, persion2.star))  # 打印persion实例的属性
print('Class star: %s' % Persion.star)  # 答应Persion类的属性
# 打印persion1、persion2实例和Persion类中star属性的id。看内存地址是否不一样
print('%s id(star): %s ' % (persion1.name, id(persion1.star)))  # 打印persion1实例的属性
print('%s id(star): %s' % (persion2.name, id(persion2.star)))  # 打印persion实例的属性
print('Class id(star): %s' % id(Persion.star))  # 答应Persion类的属性
```
#### 输出内容：
```text
Jerry star: mars 
Tom star: earth
Class star: earth
Jerry id(star): 140526009104680 
Tom id(star): 140526009103056
Class id(star): 140526009103056
```
我们可以发现，就只有persion1实例自己讲stars属性修改为了“mars”，并且内存空间也进行了修改。<br>
这说明实例并不能直接修改类的数据属性。但会重新为这个实例分配一个新的命名空间。
## **4. 实例与函数属性的关系——绑定方法**
类的函数属性是绑定给实例的。不同的实例所绑定的函数属性的名称空间地址不同。
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('learning')

    def eat(self):
        print('eating')


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print('Class NameSpace: %s' % Persion.learn)  # 打印类的learn函数属性的名称空间
print('%s NameSpace: %s' % (persion1.name, persion1.learn))  # 打印persion1实例的learn函数属性的名称空间
print('%s NameSpace: %s' % (persion2.name, persion2.learn))  # 打印persion2实例的learn函数属性的名称空间
```
#### 输出内容：
```text
Class NameSpace: <function Persion.learn at 0x7f6eee555268>
Jerry NameSpace: <bound method Persion.learn of <__main__.Persion object at 0x7f6eee5629b0>>
Tom NameSpace: <bound method Persion.learn of <__main__.Persion object at 0x7f6eee5629e8>>
```
我们可以看到，类和实例的命名空间完全的不同。并且实例的输出了
“<bound method Persion.learn of <__main__.Persion object at 0x7f6eee5629b0>>"
表明自己的内存空间是绑定到Persion类的learn函数属性。
## **5.实例调用类的函数属性**
哪实例如何调用类的函数属性？
#### 代码部分
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self):  # 定义类的函数函数
        print('%s is learning' % self.name)

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.learn()  # 调用实例的方法
persion2.learn()  # 调用实例的方法
```
#### 输出部分：
```text
Jerry is learning
Tom is learning
```
我们只要使用persion1.learn()的方式就可以调用类的函数属性。并创建实例的方法。也就是将persion1这个实例的内存空间作为learn函数的self变量，
传递到learn函数中。

## **6.实例调用带参数的类函数属性**
哪如果类中learn函数带有其他自己独有的参数呢？
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        print('%s is learning "%s"' % (self.name, lesson))

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
persion1.learn('Python')  # 调用实例的方法，并付给learn函数一个lesson变量
persion2.learn('Java')  # 调用实例的方法，并付给learn函数一个lesson变量
```
#### 输出内容
```text
Jerry is learning "Python"
Tom is learning "Java"
```
我们可以看到，通过使用persion1.learn('Python')方法就可以将learn函数中独有的变量传导进去。
# ** 第六章：实例属性的查找顺序
## ** 1. 属性的操作顺序
我们在如上章节讲了类的属性，创建实例和使用实例的属性和方法。那现在我们来看一下，实例查找属性的先后顺序。
##### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        print('%s is learning "%s"' % (self.name, lesson))

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print(persion1.__dict__)  # 实例自己的属性
print(persion2.__dict__)  # 实例自己的属性
```
#### 输出部分：
```text
{'name': 'Jerry', 'age': 28, 'sex': 'man'}
{'name': 'Tom', 'age': 28, 'sex': 'man'}
```
我们首先可以看到实例有自己的独有属性。这些属性怎么来的哪？是类中定义的__init__函数给传递进去的。所以当类没有__init__函数时，
实例默认也没有任何属性。<br>
那么大家可能有个问题。不是之前可以使用persion1.star()调用类的数据属性,不是使用persion1.learn()调用类的函数属性吗？
是的，但是这些属性。并没有存在实例的名称空间中。而是实例向自己的类进行查找而获得来的。如：<br>
#### 代码部分：
```python
class Persion:  # 定义类
    star = 'earth'  # 定义类的数据属性
    def __init__(self, name, age, sex):  # 使用__init_函数属性，定义实例变量
        self.name = name  # 实例变量
        self.age = age  # 实例变量
        self.sex = sex  # 实例变量

    def learn(self, lesson):  # 定义类的函数函数
        print('%s is learning "%s"' % (self.name, lesson))

    def eat(self):
        print('%s is eating' % self.name)


persion1 = Persion('Jerry',28, 'man')  # 创建类的实例对象“JERRY”
persion2 = Persion('Tom',28, 'man')  # 创建类的实例对象“Tom”
print(persion1.__dict__)  # 实例自己的属性
print(persion2.__dict__)  # 实例自己的属性
print(persion1.star)  # 实例到自己的类中进行查找，找到了star属性
print(persion2.star)  # 实例到自己的类中进行查找，找到了star属性
```
#### 输出内容：
```text
{'name': 'Jerry', 'age': 28, 'sex': 'man'}
{'name': 'Tom', 'age': 28, 'sex': 'man'}
earth
earth
```
如何去理解哪。实例首先在自己的名字空间中炒作star属性。发现没有？然后定位到自己的类是Persion，然后查找类的名字空间，发现了star属性。
最后将这个star属性直接调用出来。
## ** 2.总结**
1. 首先创建实例时，如果类中有__init__函数就会创建实例自己的属性。当调用实例属性时，如发现实例属性中已有。先调用实例属性。
2. 如果实例属性中没有。就向自己的类中进行查找。类中有的话，就调用类的属性。
3. 如果类也没有，报错退出。

# **第七章：对象之间的交互**
如上章节我们都是创建了不同的实例，但是实例与实例之间并没有任何的交互。本章我们来讲解一下实例之间的交互。<br>
引出一个例子：中美两个公司的之间相互转账。
#### 代码部分：
```python
class Baidu:  # 创建了一个Baidu类
    company = 'BAIDU'  # 创建了一个数据属性，百度
    def __init__(self,card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount


    def transaction(self, another):  # 类的函数，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款

class Ibm:  # 同样创建一个Ibm类
    company = 'IBM'  # 创建了一个数据属性，百度
    def __init__(self, card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount

    def transaction(self, another):  # 类的函数属性，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款


baidu = Baidu('123456', 23, 10)  # 使用中国类创建一个百度的实例
ibm = Ibm('654321', 13, 10)  # 使用美国类创建一个ibm的实例
baidu.transaction(ibm)  # 百度转账给ibm
print('BAIDU card [%s] persent balance: %s'% (baidu.card,baidu.balance))  # 答应百度的当前银行卡余额
print('IBM card [%s] persent balance: %s'% (ibm.card,ibm.balance))  # 答应ibm的当前银行卡余额
```
#### 输出结果：
```text
BAIDU card [123456] persent balance: 13
IBM card [654321] persent balance: 23
```
我们看到通过在类的 def transaction(self, another)函数属性中增加一个形参（another），它的实参就是另一个实例。
这种方式就实现的实例之间的交互，一个实例触发的方法会对其他实例产生联动性
# **第八章：补充知识**
1. 站的角度不同，定义出的类截然不同
2. 现实中的类并不一定等于程序中的类，比如现实中的公司类，现实拆分为业务、部门类
3. 有时编程需要，程序可以定义现实中不存在的类。如：策略类。


# ** 第九章： 继承**
继承指的是类与类之间的关系，在python中，新建的类可以继承一个或多个父类，父类也可以称为基类或超类
，新建的类称为派生类或子类。子类与父类之间是is的关系，父类有的属性和方法，子类中也都可以使用。
继承的功能之一用来解决代码的重用性。
## ** 1.继承的语法**
```python
class ParentClass1:  # 父类
    pass

class ParentClass2:  # 父类
    pass

class SubClass1(ParentClass1):  # 子类继承ParentClass1父类
    pass

class SubClass2(ParentClass1,ParentClass2):  # 子类继承ParentClass1,ParentClass2父类
    pass
```
## **2. 查询类的继承关系**
我们如何去查找某个类是否有自己的继承关系哪？
###### 代码部分：
```python
class ParentClass1:  # 父类
    pass

class ParentClass2:  # 父类
    pass

class SubClass1(ParentClass1):  # 子类继承ParentClass1父类
    pass

class SubClass2(ParentClass1,ParentClass2):  # 子类继承ParentClass1,ParentClass2父类
    pass

print(SubClass1.__bases__)  # 查看SubClass1类的父类
print(SubClass2.__bases__)  # 查看SubClass2类的父类
```
###### 输出部分：
```text
(<class '__main__.ParentClass1'>,)
(<class '__main__.ParentClass1'>, <class '__main__.ParentClass2'>)
```

#### ** 3. 子类与父类的关系
我们之前提到了子类和父类是is的关系。怎么去理解这句话，我们用“对象之间的交互”章节中的代码来讲解一下：
```python
class Baidu:  # 创建了一个Baidu类
    company = 'BAIDU'  # 创建了一个数据属性，百度
    def __init__(self,card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount


    def transaction(self, another):  # 类的函数，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款

class Ibm:  # 同样创建一个Ibm类
    company = 'IBM'  # 创建了一个数据属性，百度
    def __init__(self, card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount

    def transaction(self, another):  # 类的函数属性，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款


baidu = Baidu('123456', 23, 10)  # 使用中国类创建一个百度的实例
ibm = Ibm('654321', 13, 10)  # 使用美国类创建一个ibm的实例
baidu.transaction(ibm)  # 百度转账给ibm
print('BAIDU card [%s] persent balance: %s'% (baidu.card,baidu.balance))  # 答应百度的当前银行卡余额
print('IBM card [%s] persent balance: %s'% (ibm.card,ibm.balance))  # 答应ibm的当前银行卡余额
```
如上的代码，我们创建了2个公司的类，一个是Baidu，另一个是Ibm。那么他们是否可以有一个父类。当然可以！我们定义一个Company的类，
那么这个Company的类也有自己的构建函数和transaction的函数属性哪？必然是可以的。修改代码如下：
###### 代码部分：
```python
class Company:  # 父类
    def __init__(self,card, balance, amount):  # 构造函数，支持在创建类的实例时，倒入信用卡号，余额，转账款三个参数
        self.card = card
        self.balance = balance
        self.amount = amount


    def transaction(self, another):  # 类的函数，转账
        self.balance -= self.amount  # 自己的余额减去转账款
        another.balance += self.amount  # 对方的余额加上转账款


class Baidu(Company):  # Baidu类继承Company父类
    name = 'BAIDU'  # 创建了一个数据属性，百度


class Ibm(Company):  # Ibm类继承Company父类
    name = 'IBM'  # 创建了一个数据属性，百度



baidu = Baidu('123456', 23, 10)  # 使用中国类创建一个百度的实例
ibm = Ibm('654321', 13, 10)  # 使用美国类创建一个ibm的实例
baidu.transaction(ibm)  # 百度转账给ibm
print('BAIDU card [%s] persent balance: %s'% (baidu.card,baidu.balance))  # 打印百度的当前银行卡余额
print('IBM card [%s] persent balance: %s'% (ibm.card,ibm.balance))  # 打印ibm的当前银行卡余额
```
###### 输出部分：
```text
BAIDU card [123456] persent balance: 13
IBM card [654321] persent balance: 23
```
我们可以发现Baidu、IBM类并没有定义构建函数和函数属性。但是程序还是照样运行正常。这就说明了，父类中定义的所有东西，如果子类中没有定义相同的内容的化。子类就会默认调用父类中的所有的属性。

#### **4.继承中实例属性的查找先后顺序
我们知道普通类中，实例属性的查找先后顺序如下：
1. 首先创建实例时，如果类中有__init__函数就会创建实例自己的属性。当调用实例属性时，如发现实例属性中已有。先调用实例属性。
2. 如果实例属性中没有。就向自己的类中进行查找。类中有的话，就调用类的属性。
3. 如果类也没有，报错退出。
但在继承类中哪？查找顺序如下：
1. 首先创建实例时，会在自己类中查找是否有__init__函数。有的话，就会创建实例自己的属性，但是如果自己类中没有__init__函数，就会从自己的父类中取查找__init__函数，
如果父类有的话，就继承父类的__init__函数，创建实例自己的属性。当父类也没有的话，实例就不带任何属性。
2. 如果实例属性中没有。就向自己的类中进行查找。类中有的话，就调用类的属性。如果自己类中没有，就向父类中查找，类中有的话，就调用父类的属性
3. 如果父类也没有，报错退出。
但是我们看一下如下这个代码：
##### 代码部分：
```python
class Company:  # 父类
    def transaction(self):  # 类的函数，转账
        print("Transaction monry to your Comany")
        self.purchase()  # 调用实例的采购函数。等于：badiu.purchase


    def purchase(self):  # 类的函数，采购
        print("Your Comany can purchase something.")


class Baidu(Company):  # Baidu类继承Company父类
    def purchase(self):  # 派生一个自己的采购函数
        print("My Comany can purchase Phone.")

baidu = Baidu()  # 使用中国类创建一个百度的实例
baidu.transaction()
```
###### 输出内容：
```text
Transaction monry to your Comany
My Comany can purchase Phone.
```
我们来看一下输出的内容。
- 第一行的“Transaction monry to your Comany”很好理解。当实例调用transcation时，它去查找自己的属性。
发现自己的实例属性中并没有transcation这个属性，所以到Baidu类中取查找，也发现没有。就到父类company中去查找，找到后就打印出结果（这就是类的继承）。
- 然后发现父类company在transcation属性中还有一段self.purchase()代码。程序会将自己的实例baidu作为self的实参传递给transcation属性。所以self.purchase()代码就等同于
baidu.purchase()。这时baidu实例又触发了一次查找动作。先从自己的实例中查找属性，没有找到。然后在自己的baidu类中查找到了purchase属性。
最后打印出“My Comany can purchase Phone”，而非父类company的“Your Comany can purchase something.”


# ** 第十章：派生**
派生就是子类在继承父类的基础上衍生出新的属性。子类中独有的，父类中没有的；或子类定义与父类重名的东西。子类也叫派生类。
###### 代码部分：
```python
class Company:  # 父类
    name = 'Company' # 父类的name数据属性
    def transaction(self):  # 类的函数属性，转账
        print("Transaction monry to your Comany")
        self.purchase()  # 调用实例的采购函数


    def purchase(self):  # 类的函数属性，采购
        print("Your Comany can purchase something.")


class Baidu(Company):  # Baidu类继承Company父类
    name = 'Baidu'  # 派生一个自己的数据属性
    def purchase(self):  # 派生一个自己的采购函数属性
        print("My Comany can purchase Phone.")

    def website(self):  # 派生一个自己专用的website函数属性。父中没有
        print("www.badiu.com")
```
# ** 第十一章：继承实现原理 **
#### ** 1. 继承的查找原则
python对于定义的每一个类，都会计算出一个方法解析顺序（MPO）列表，这个MPO列表就是一个简单的所有积累的线性顺序列表，
使用mro属性可以查看这个列表：
```text
>>>> Baidu.mro()  # 等同于Baidu.__mro__
[<class '__main__.Baidu'>, <class '__main__.Company'>, <class 'object'>]
```
为了实现继承python会在MRO列表上从左到右查找基类，直到找到第一个匹配的属性为止，而这个MRO列表的构造是通过一个C3线性化
算法来实现的。我们不去深究这个算法的原理，它实际上是合并所有父类的MRO列表并遵循如下原则：
1. 子类会先于父类查找。
2. 多个父类会根据他们在列表中的顺序被查找。
3. 如果有多个类存在相同的属性，使用第一个属性。
#### ** 2. 继承的查询类型——深度优先、广度优先
上面的讲了一个类的查询原则，是依据MRO列表从左到右查找自己的父类。但程序中的类与类之间存在了多种继承的关系，
也就是说，一个父类也可能是其他父类的一个子类。那么一个python中如何最终定位到父类哪？在将这个问题前，我们先引出
python中对类的两个分类的定义与他们的查找方式：<br>
1. 经典类：没有继承object的类，以及他的子类称为经典类，只有在python2中有这个概念。经典类以深度优先的方式查询。语法如下：
> 经典类的语法：
> ```python
> class Foo:
>     pass
> class Bar(Foo):
>     pass
> ```
2. 新式类：继承object的类，以及他的子类称为经典类。python3中所有类都是新式类。新式类以广度优先的方式查询。语法如下：
> 新式类的语法：
> ```python
> class Foo:
>     pass
> class Bar(Foo):
>     pass
> ```
#### ** 3.深度优先查找与广度优先查找的区别
经典类继承查找的先后顺序按照深度优先的方式查找。如何去理解。请看下图：
![深度优先查询](https://github.com/henryyuan/first-app/blob/master/homework/Module3/Study_Note/%E7%BB%A7%E6%89%BF%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%9F%A5%E8%AF%A2.png)
新式类继承查找的先后顺序按照广度优先的方式查找如何去理解。请看下图：
![广度优先查询](https://github.com/henryyuan/first-app/blob/master/homework/Module3/Study_Note/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%9F%A5%E8%AF%A2.png)
深度优先查询规则：
1. A类查询自己的第一个父类B。跳转给B类。
2. B类发现自己并没有A需要的属性，但发现自己有一个父类E。跳转给E类。
3. E类发现自己并没有A需要的属性，但发现自己有一个父类G。跳转给G类。
4. G类有A类需要的属性，返回给A。结束查找。
广度优先查询规则：
1. A类查询自己中的第一个父类B。跳转给B类。
2. B类发现自己并没有A需要的属性，但发现自己有一个父类E。跳转给B类。
3. E类发现自己并没有A需要的属性，但发现自己有一个父类G。
4. 跳过G类，继续查找C类。
5. C类发现自己并没有A需要的属性，但自己有一个父类F。跳转给F类。
6. F类发现自己并没有A需要的属性，然自己有一个父类G。
7. 跳过G类，继续查找D类。
8. D类发现自己并没有A需要的属性，但自己有个父类G类。并且发现自己已经是A类的最后一个父类。跳转给G
9. G发现自己有A需要的属性，返回给A。结束查询。

#### 4.新式类的mro方法
mro的作用就是查询类的MRO列表。
我们模拟一下上面中新式类的例子来看一下mro方法的用法。
###### 代码部分：
```python
class G(object):
    def show(self):
        print("I am G")

class F(G):
    def show(self):
        print("I am F")

class E(G):
    def show(self):
        print("I am E")

class D(G):
    def show(self):
        print("I am D")

class C(F):
    def show(self):
        print("I am C")

class B(E):
    def show(self):
        print("I am B")

class A(B, C ,D):
    pass

print(A.mro())
```
###### 输出部分：
```text
[<class '__main__.A'>, <class '__main__.B'>, <class '__main__.E'>, <class '__main__.C'>, <class '__main__.F'>, <class '__main__.D'>, <class '__main__.G'>, <class 'object'>]
```
可以看到A类的查询顺序完全符合广度优先的规则A-B-E-C-F-D-G的顺序。

# 多态和多态性
## 1. 多态的概念
多态指的是一个类事物有多种形态。比如：
- 动物有多种形态：人、狗、猫、等
- 文件有多种形态：文本文件、可执行文件、等
如下代码就是一个以多态概念编写的代码。
```python
import abc


class Animal(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def talk(self):
        pass
    
    
class Persion(Animal):  # Animal的一种形态
    def talk(self):
        print('I am man')
        

class Dog(Animal):  # Animal的一种形态
    def talk(self):
        print('wangwang')

        
class Cat(Animal):  # Animal的一种形态
    def talk(self):
        print('miaomiao')
```

## 2. 多态性的概念
动态性又称为多态动态绑定（需要在继承的背景下使用）。
多态性指的是可以在不考虑对象的类型的情况下而直接使用对象。更通俗的来说，
在调用方式不变的情况下，可以返回多种不同的执行效果。
如何去理解这句话哪？使用如下代码讲解
```python
import abc


class Animal(metaclass=abc.ABCMeta):  # Animal抽象类
    @abc.abstractmethod
    def talk(self):  # 定义talk方法规范
        pass


class Persion(Animal):  # Animal的一个形态
    def talk(self):  # Persion的talk方法
        print('I am man')


class Dog(Animal):  # Animal的一个形态
    def talk(self):  # Dog的talk方法
        print('wangwang')


class Cat(Animal):  # Animal的一个形态
    def talk(self):  # Cat的talk方法
        print('miaomiao')
# 可以看到Animal类中的有多个形态的类。并且这些形态的talk方法的执行后会得到不同的结果。
# 多态性依赖于继承和抽象类（抽象类的作用是定义更好的接口规范）

# 多态性：通过使用一个函数，多种形态的实例进行统一，让不同的对象都可以执行相同的方法，返回不同的结果
def func(animal):  # animal形参的实参Animal形态的实例。
    animal.talk()  # 所有实例执行相同的talk方法

per1 = Persion()
dog1 = Dog()
cat1 = Cat()

func(per1)
func(dog1)

```
如上代码的开始部分如下：
```python
import abc


class Animal(metaclass=abc.ABCMeta):  # Animal抽象类
    @abc.abstractmethod
    def talk(self):  # 定义talk方法规范
        pass


class Persion(Animal):  # Animal的一个形态
    def talk(self):  # Persion的talk方法
        print('I am man')


class Dog(Animal):  # Animal的一个形态
    def talk(self):  # Dog的talk方法
        print('wangwang')


class Cat(Animal):  # Animal的一个形态
    def talk(self):  # Cat的talk方法
        print('miaomiao')
```
只是定义了一个Animal类的多态。然而后续的代码就反应了多态性。如下：
```python
# 多态性：通过使用一个函数，多种形态的实例进行统一，让不同的对象都可以执行相同的方法，返回不同的结果
def func(animal):  # animal形参的实参Animal形态的实例。
    animal.talk()  # 所有实例执行相同的talk方法

per1 = Persion()
dog1 = Dog()
cat1 = Cat()

func(per1)
func(dog1)
```
无论Animal类中的其他形态，创建了任何实例。都可以只用一种方法talk去执行，并返回不同的结果。
并且通过定义一个func(animal)函数的方式，创建出一个新的接口。这个接口，更加的规范了不同对象调用自己的talk方法。
所以多态性，就是将不同形态的方法进行统一（方法名称使用相同名称）。并通过使用一个新的接口(func函数)的方法，将这些方法进行整合。最后所有的实例，都只是这个接口的参数。
达到在调用方式不变的情况下，可以返回多种不同的执行效果的目的。
## 3. 静态多态性和动态多态性
静态多态性：如任何类型都可以使用+进行运算
动态多态性：就是如上代码。

## 4. 多态性的优点
1. 增加了程序的灵活性：无论对象发生了发生了什么变化，使用者都是用同一种形态去调用。
2. 增加了程序的可扩展性：在类中增加一个新的形态，使用者也无需修改自己的代码。我们可以随意的在上面的代码中增加一个pig类，但使用者的调用方式并不需要改变。

## 5.鸭子类型



    ‘ 那只东西呱呱的叫，有扁扁的嘴巴，走起路来还外八，对！它就是只鸭子’


首先Python不需要支持多态。因为python就是一种支持多态的语言（动态语言）。而鸭子类型是动态语言里面的一种概念。
在程序设计中，鸭子类型（英语：duck typing）是动态语言的一种风格。在这种风格中，
一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定
也就是说，在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭的对象，并调用它的走和叫方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。
python中的具体实现
下面的代码就是一个简单的鸭子类型
```python
class duck():
    def walk(self):
        print('I walk like a duck')
    def swim(self):
        print('i swim like a duck')

class person():
    def walk(self):
        print('this one walk like a duck') 
    def swim(self):
        print('this man swim like a duck')
```
如上代码，可以发现有两个类duck和person虽然它们是不同的类。但又相同的方法。
对于一个鸭子类型来说，我们并不关心这个对象的类型本身或是这个类继承，而是这个类是如何被使用的。

我们可以通过下面的代码来调用这些类的方法。
```python
def watch_duck(animal):
    animal.walk()
    animal.swim()

small_duck = duck()
watch_duck(small_duck)

output >> 
I walk like a duck
i swim like a duck


duck_like_man = person()
watch_duck(duck_like_man)

output >> 
this one walk like a duck
this man swim like a duck


class Lame_Foot_Duck():
    def swim(self):
        print('i am lame but i can swim')

lame_duck = Lame_Foot_Duck()
watch_duck(lame_duck)

output >>
AttributeError: Lame_Foot_Duck instance has no attribute 'walk'
```
可以从如上代码看出，基于鸭子类型设计的程序，对象完全不在乎它是属于persion还是duck类型，只要有相同的方法，就执行代码
watch_duck函数接收这个类的对象，然后并没有检查对象的类型，而是直接调用这个对象的走和游的方法，如果所需要的方法不存在就报错。

# **封装**
封装（Encapsulation）是对具体对象的一种抽象，即是将某些部分隐藏起来。但封装并不完全等于隐藏，
通过封装，类外部无法调用该类的属性和方法，其含义就是使得其他类无法调用这些已经封装的属性和方法。
要了解封装，离不开“私有化”，就是将类或者是函数中的某些属性限制在某个区域之内，外部无法调用。
# **封装的语法**
在python中用双下划线开头的方式将属性和方法隐藏起来。
封装类的数据属性：
```python
class A:
    __N = 0  # 将类的数据属性封装
```
封装类的函数属性：
```python
class A:
    def __foo(self):
        pass
```
封装实例的属性：
```python
class A:
    def __init__(self,name):
        self.__name = name
```
# **封装的实现原理**
封装的目的就是让类中的一些属性和方法，无法被类的外部直接调用。哪python如何实现封装？
其实，封装仅仅是在类定义阶段。将类中所有双下划线开头的名称如__x都会自动变形成：_类名__x的形式。使用如下代码解析封装的实现原理。
#### 代码部分
```python
class A:
    __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N
    def __init__(self, name):
        self.__name = name #变形为self._name__X
    def __foo(self): #变形为_A__foo
        print('from A')


print('类A属性：%s ' % A.__dict__)
a = A('henry')
print('实例a属性：%s' % a.__dict__)
print('访问类的封装属性：%s', A._A__N)
print('访问实例的封装属性：%s', a._A__name)
```
#### 输出部分
```text
类A属性：{'__module__': '__main__', '_A__N': 0, '__init__': <function A.__init__ at 0x7fc30538e158>, '_A__foo': <function A.__foo at 0x7fc30538e1e0>, '__dict__': <attribute '__dict__' of 'A' objects>, '__weakref__': <attribute '__weakref__' of 'A' objects>, '__doc__': None} 
实例a属性：{'_A__name': 'henry'}
访问类的封装属性：%s 0
访问实例的封装属性：%s henry
```
可以从类和实例的命名空间中看到。所有以双下划线开头的属性名称。都在类的定义阶段，装换成了“_所在类名__属性”名称。起到了隐藏的作用。
但是，这种属性名称的变形，可以再类的外部通过“类名._类名__属性”的语句直接访问到的类中的封装属性、可以通过“实例._类名__属性”的方式访问到实例的封装属性和方法。所以这种操作并不是严格意义上的限制外部访问，仅仅只是一种语法意义上的变形。
但实际上，直接去访问变形后的属性名称也是不合理的。
# **封装的特性**
封装有如下三个特性：
- 类的外部，无法直接使用obj.__AttrName的方式访问
#### 代码部分
```python
class A:
    __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N
    def __init__(self, name):
        self.__name = name #变形为self._name__X
    def __foo(self): #变形为_A__foo
        print('from A')


a = A('henry')
print('访问类的封装属性：%s', A.__N)
```
#### 输出部分
```text
Traceback (most recent call last):
  File "/development/homework/test.py", line 10, in <module>
    print('访问类的封装属性：%s', A.__N)
AttributeError: type object 'A' has no attribute '__N'
```
可以看到，如果直接使用“类名.__属性”或者“实例名.__属性”的方式，是无法访问已经封装的属性的。python直接会报出未找到属性的错误。
其实根本的原因就是“类名.__属性”和“实例名.__属性”，被修改为了“类名._类名__属性”和“实例名._类名__属性”。
- 类的内部，可以使用obj.__AttrName的方法访问。
#### 代码部分
```python
class A:
    __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N
    def __init__(self, name):
        self.__name = name #变形为self._A__X

    def __foo(self): #变形为_A__foo
        print('from A')

    def bar(self):
        self.__foo() #只有在类内部才可以通过__foo的形式访问到。其实原理也是在类定义时，变形成self._A__foo

a = A('henry')
a.bar()
```
#### 输出部分
```text
from A
```
类内部才可以通过__foo的形式访问到封装的属性。其实原理也与封装修改属性名称有关。封装在类定义时，将self.__foo()变形成self._A__foo()。这样就找到了已经封装的__foo属性。
- 子类无法覆盖父类同名的封装后的属性。因为子类中变形成了：_子类名__x,而父类中变形成了：_父类名__x，即双下滑线开头的属性在继承给子类时，子类是无法覆盖的。
#### 代码部分：
```python
class A:
    def __foo(self): #变形为_A__foo
        print('from A')


class B(A):
    def __foo(self):  # 变形为_B__foo
        print('from B')
```
如上子类的封装属性__foo虽然看上去与父类的__foo属性一样。但其实在类的定义阶段，这两个属性都被重名成不同的属性名称。所以子类和父类中重名的封装属性，子类并不能覆盖父类的封装属性。

封装的注意事项：
1、这种封装的变形机制也并没有真正意义上限制我们从外部直接访问属性，知道了类名和属性名就可以拼出名字：_类名__属性，然后就可以访问了，如a._A__N
2、变形的过程只在类的定义是发生一次,在定义后的赋值操作，不会变形
#### 代码部分
```python
class A:
    __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N
    def __init__(self, name):
        self.__name = name #变形为self._A__X

    def __foo(self): #变形为_A__foo
        print('from A')

    def bar(self):
        self.__foo() #只有在类内部才可以通过__foo的形式访问到。其实原理也是在类定义时，变形成self._A__foo


a = A('henry')
a.__Y = 1  # 给实例增加属性。
print('实例中的属性：%s' % a.__dict__)
```
#### 输出内容
```text
实例中的属性：{'_A__name': 'henry', '__Y': 1}
```
可以看到，类定义完后，实例时无法通过增加属性的方式添加一个封装的属性的。
3、在继承中，父类如果不想让子类覆盖自己的方法，可以将方法定义为私有的
```python
#正常情况
>>> class A:
...     def fa(self):
...         print('from A')
...     def test(self):
...         self.fa()
... 
>>> class B(A):
...     def fa(self):
...         print('from B')
... 
>>> b=B()
>>> b.test()
from B


#把fa定义成私有的，即__fa
>>> class A:
...     def __fa(self): #在定义时就变形为_A__fa
...         print('from A')
...     def test(self):
...         self.__fa() #只会与自己所在的类为准,即调用_A__fa
... 
>>> class B(A):
...     def __fa(self):
...         print('from B')
... 
>>> b=B()
>>> b.test()
from A
```


# **封装的意义**
封装并不止隐藏属性这么简单。我们来看一下封装用法的实际意义。
## 1 封装数据
将数据属性封装起来，可以隐藏起来然后对外提供操作该数据的接口，然后我们可以在接口附加上对该数据操作的限制，以此完成对封装数据属性的操作进行严格控制。
```python
class Teacher:
    def __init__(self,name,age):
        self.__name=name
        self.__age=age

    def tell_info(self):
        print('姓名:%s,年龄:%s' %(self.__name,self.__age))
    def set_info(self,name,age):  # 修改封装属性的接口函数
        if not isinstance(name,str):  # 对传入的参数进行一定的现在
            raise TypeError('姓名必须是字符串类型')
        if not isinstance(age,int):
            raise TypeError('年龄必须是整型')
        self.__name=name
        self.__age=age

t=Teacher('egon',18)
t.tell_info()

t.set_info('egon',19)  # 使用set_info接口函数，修改封装函数。
t.tell_info()
```

## 2. 封装方法：目的是隔离复杂度
类中可能定义了多种方法，但这些方法最后可以汇聚成一个接口。比如：电视机，电视机内部有很多电器元件，分别处理各自的功能。但对于
用户来说，我们不需要清楚里面元件的功能，我们只需要使用遥控器提供给用户的几个按钮来对电视机进行操作。
在这个比方中，电视机就是类，电器元件就是类中多种方法。遥控器就是接口，遥控器的按钮就是接口函数。
所以封装方法的目的，就是将原有类中复杂的方法集合起来。提供一个统一的接口函数。让外部直接去调用。
#### 
```python
#取款是功能,而这个功能有很多功能组成:插卡、密码认证、输入金额、打印账单、取钱
#对使用者来说,只需要知道取款这个功能即可,其余功能我们都可以隐藏起来,很明显这么做
#隔离了复杂度,同时也提升了安全性

class ATM:
    def __card(self):
        print('插卡')
    def __auth(self):
        print('用户认证')
    def __input(self):
        print('输入取款金额')
    def __print_bill(self):
        print('打印账单')
    def __take_money(self):
        print('取款')

    def withdraw(self):
        self.__card()
        self.__auth()
        self.__input()
        self.__print_bill()
        self.__take_money()

a=ATM()
a.withdraw()
```


提示：在编程语言里，对外提供的接口（接口可理解为了一个入口），可以是函数，称为接口函数，这与接口的概念还不一样，接口代表一组接口函数的集合体。

# **封装的可扩展性**
封装在于明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者的代码；而外部使用用者只知道一个接口(函数)，只要接口（函数）名、参数不变，
使用者的代码永远无需改变。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑。
```python
#类的设计者
class Room:
    def __init__(self,name,owner,width,length,high):
        self.name=name
        self.owner=owner
        self.__width=width
        self.__length=length
        self.__high=high
    def tell_area(self): #对外提供的接口，隐藏了内部的实现细节，此时我们想求的是面积
        return self.__width * self.__length


#使用者
>>> r1=Room('卧室','egon',20,20,20)
>>> r1.tell_area() #使用者调用接口tell_area


#类的设计者，轻松的扩展了功能，而类的使用者完全不需要改变自己的代码
class Room:
    def __init__(self,name,owner,width,length,high):
        self.name=name
        self.owner=owner
        self.__width=width
        self.__length=length
        self.__high=high
    def tell_area(self): #对外提供的接口，隐藏内部实现，此时我们想求的是体积,内部逻辑变了,只需求修该下列一行就可以很简答的实现,而且外部调用感知不到,仍然使用该方法，但是功能已经变了
        return self.__width * self.__length * self.__high


#对于仍然在使用tell_area接口的人来说，根本无需改动自己的代码，就可以用上新功能
>>> r1.tell_area()
```
# **特性（property）**
property是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值。property也是一个装饰器。
我们用一个例子来说明。就用计算房间面积的代码。（面积是计算而来的，很显然它更像是房子的一个属性而非方法）。
#### 代码部分
```python
class Room:
    def __init__(self,name,owner,width,length,high):
        self.name=name
        self.owner=owner
        self.__width=width
        self.__length=length
        self.__high=high
    
    def area(self):
        return self.__width * self.__length


#使用者
r1=Room('卧室','egon',20,20,20)
print(r1.area()) #使用者调用接口tell_area
```
如上代码，可以看到的是，对象调用面积时，使用了r1.area()他是一种调用方法的语句。对于这个对象的编写者就会产生一个疑惑。这个area明明像一个数据属性，
但为什么需要用方法的方式去调用哪？
哪对象是否可以使用调用数据属性的方式调用方法哪？
#### 代码部分
```python
class Room:
    def __init__(self, name, owner, width, length, high):
        self.name = name
        self.owner = owner
        self.__width = width
        self.__length = length
        self.__high = high

    @property
    def area(self):
        return self.__width * self.__length


# 使用者
r1 = Room('卧室', 'egon', 20, 20, 20)
print(r1.area)  # 使用调用数据属性的方式，调用了一个方法属性
```
所以@property装饰器的作用，就是原来调用方法的r1.area()方式，装饰为调用数据属性的r1.area方式。

# **property意义**
将一个类的函数定义成特性以后，对象再去调用的时候,根本无法察觉自己的调用的是一个方法，而不是数据属性。
特性的使用方式，是为了遵循了统一访问的原则：
    All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation
翻译：一个模块提供的所有服务都应该通过统一记号提供出来，这并不意味着它们是通过存储还是通过计算实现的。
也可以理解为，如果类中有方法是执行的计算代码，并且返回的数据可以作为对象的一个属性。就应该使用peroperty特性，将它的调用方式转换成数据属性的调用方式。

# ** propert扩展**
除此之外，看下
ps：面向对象的封装有三种方式:
【public】
这种其实就是不封装,是对外公开的
【protected】
这种封装方式对外不公开,但对朋友(friend)或者子类公开
【private】
这种封装对谁都不公开
python并没有在语法上把它们三个内建到自己的class机制中，在C++里一般会将所有的所有的数据都设置为私有的，然后提供set和get方法（接口）去设置和获取，在python中通过property方法可以实现
class Foo:
    def __init__(self,val):
        self.__NAME=val #将所有的数据属性都隐藏起来

    @property
    def name(self):
        return self.__NAME #obj.name访问的是self.__NAME(这也是真实值的存放位置)

    @name.setter
    def name(self,value):
        if not isinstance(value,str):  #在设定值之前进行类型检查
            raise TypeError('%s must be str' %value)
        self.__NAME=value #通过类型检查后,将值value存放到真实的位置self.__NAME

    @name.deleter
    def name(self):
        raise TypeError('Can not delete')

f=Foo('egon')
print(f.name)
# f.name=10 #抛出异常'TypeError: 10 must be str'
del f.name #抛出异常'TypeError: Can not delete'

面向对象开发的三大特性继承、多态、封装。

# 绑定方法与非绑定方法
在类内部定义的函数，分为两大类：
一、 绑定方法：绑定给谁，谁才能使用。
- 绑定到对象的方法：
在类内定义的没有被任何装饰器修饰的函数。就是一个绑定到对象的方法。只有绑定给的对象才能使用这个方法。
#### 代码部分
```pyton
class People:
    def __init__(self, name, ):
        self.name = name

    def tell(self):
        print(self.name)


p1 = People('henry')
print('打印p1对象:', p1)
print('打印p1对象的tell方法:',p1.tell)  # 绑定到对象的方法
```
#### 输出内容
```text
打印p1对象: <__main__.People object at 0x7f287c1e1390>
打印p1对象的tell方法: <bound method People.tell of <__main__.People object at 0x7f287c1e1390>>
```
如上代码的输出。我们可以确认，People类中的tell函数属性。是绑定给p1对象的一个办法( <bound method People.tell of <\_\_main\_\_.People object at 0x7f287c1e1390>>)。
所以总结一下，绑定给对象的方法。就是，将一个方法绑定给一个对象，就应该由该对象来调用，对象来调用的话，就把调用对象，当做第一个参数自动传入。
- 绑定到类的方法:在类内定义的被任何装饰器classmethod修饰的函数
#### 代码部分
```python
class People:
    def __init__(self, name, ):
        self.name = name

    def tell(self):
        print(self.name)

    @classmethod
    def func(cls):
        print(cls)


p1 = People('henry')
print('打印People类的命名空间:', People)
print('打印的绑定给People类的func方法的命名空间:',People.func)  # 绑定到类的方法
print('打印p1对象调用func方法的命名空间:', p1.func)  # 就算是类的对象来调用该方法。该方法还是绑定给类的。
```
#### 输出内容
```text
打印People类的命名空间: <class '__main__.People'>
打印的绑定给People类的func方法的命名空间: <bound method People.func of <class '__main__.People'>>
打印p1对象调用func方法的命名空间: <bound method People.func of <class '__main__.People'>>
```
如上代码可以确认，People类中的func函数属性。是绑定给People类的一个办法(  <bound method People.func of <class '__main__.People'>>)。就算是类的实例去调用方法，
它还是绑定给People类的一个方法。
所以总结一下，绑定给类的方法。就是，将一个方法绑定给一个类，就应该由该类来调用，类来调用的话，就把调用类，当做第一个参数自动传入。
二、非绑定方法：
在类内定义的被装饰器staticmethod修饰的函数。被装饰后，该方法就变成了一个普通的函数，不与类和对象绑定的方法。不进行自动传self、cls值。类和对象都可以使用这个函数。
#### 代码部分
```python
class People:
    def __init__(self, name, ):
        self.name = name

    def tell(self):
        print(self.name)

    @classmethod
    def func(cls):
        print(cls)

    @staticmethod
    def foo(age):
        print(age)

p1 = People('henry')
print('打印People类调用foo方法的命名空间:',People.foo)  # foo非绑定到People类
print('打印p1对象调用foo方法的命名空间:', p1.foo)  # foo非绑定到p1对象

# 非绑定方法foo的使用。就像普通的一个函数。
People.foo(12)  # 
p1.foo(13)

```
#### 输出内容
```text
打印People类调用foo方法的命名空间: <function People.foo at 0x7f1de1cf02f0>
打印p1对象调用foo方法的命名空间: <function People.foo at 0x7f1de1cf02f0>
12
13
```
如上代码可以确认，foo方法没有绑定给类、对象。它就是一个普通的函数(  <function People.foo at 0x7f1de1cf02f0>)。

# 绑定方法和非绑定方法的应用。
我们通过一个案例来讲一个绑定方法与非绑定方法在实际项目中如何去使用。
```python
class People:
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex

    def tell_info(self):  # 绑定给对象的方法
        obj_info = """-------PEOPLE INFO--------
        Name:    %s
        Age:     %s
        Sex:     %s 
        """ % (self.name, self.age, self.sex)
        print(obj_info)


# 绑定给对象的方法，就应该对象来调用。
henry = People('henry',29,'man')
henry.tell_info()
```
首先，tell_info方法是一个打印对象信息的方法。这个方法中的name、age、sex都是对象的独有属性。需要在实例化对象时导入。所以，
tell_info方法必须使用绑定到对象的方法。
我们现在增加一个功能，需要用户信息可以通过配置文件进行导入,最终实例化成为一个对象。并且，这个配置文件导入的功能必须是People类的一个方法。
修改代码如下：
```python
import settings
class People:
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex

    def tell_info(self):  # 绑定给对象的方法
        obj_info = """-------PEOPLE INFO--------
        Name:    %s
        Age:     %s
        Sex:     %s 
        """ % (self.name, self.age, self.sex)
        print(obj_info)

    def import_conf(whatever):  # whatever只是一个参数，而不是指代任何对象。虽然没有定义staticmethod装饰器，但这个方法的本质就是一个非绑定方法
        obj = People(settings.name, settings.age, settings.sex)  # 创建一个People类的对象。这个对象所有的参数来源是settings这个配置文件
        return obj  # 返回这个对象


jerry = People.import_conf(123123)
jerry.tell_info()
```
这段代码的import_conf方法并不是一个绑定给对象的方法。它本质上是一个非绑定方法。因为在它的函数内部的所有代码并没有用到任何对象或类。
通过在这个import_conf方法中实例化一个从settings配置文件中，导入各个参数的对象。并返回这个对象的方式。生成了一个从配置文件导入的对象。
但如上的代码有个重大的缺陷，就是People这个类名，可能会发生改变。所以更好的方法是使用绑定类的方法来进行编写。
```python
import settings
class People:
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex

    def tell_info(self):  # 绑定给对象的方法
        obj_info = """-------PEOPLE INFO--------
        Name:    %s
        Age:     %s
        Sex:     %s 
        """ % (self.name, self.age, self.sex)
        print(obj_info)

    @classmethod
    def import_conf(cls):  # 绑定给类的方法
        obj = cls(settings.name, settings.age, settings.sex)  # 产生obj对象的类，由cls参数导入。
        return obj  # 返回这个对象


# 绑定给类的方法，就应该对象来调用。
jerry = People.import_conf()
jerry.tell_info()
```
再增加一个需求，需要给每个对象创建一个唯一的id号。这个id号由创建时间进行MD5校验而来。
```python
import settings
import hashlib
import time

class People:
    def __init__(self, name, age, sex):
        self.id = self.create_id()  # 每个对象都可以调用create_id非绑定方法，生成ID。并作为自己的属性
        self.name = name
        self.age = age
        self.sex = sex

    def tell_info(self):  # 绑定给对象的方法
        obj_info = """-------PEOPLE INFO--------
        ID:      %s
        Name:    %s
        Age:     %s
        Sex:     %s 
        """ % (self.id, self.name, self.age, self.sex)
        print(obj_info)

    @classmethod
    def import_conf(cls):
        obj = cls(settings.name, settings.age, settings.sex)  # 产生obj对象的类，由cls参数导入。
        return obj  # 返回这个对象


    @staticmethod
    def create_id():  # 非绑定方法，代码内部并不需要对象和类传递进来。
        id = hashlib.md5(str(time.time()).encode('utf-8'))  # 计算MD5值。
        return id.hexdigest()


# 绑定给对象的方法，就应该对象来调用
henry = People('henry', 29, 'man')
henry.tell_info()
# 绑定给类的方法，就应该类来调用。
jerry = People.import_conf()
jerry.tell_info()
# 非绑定方法，不与类和对象绑定，谁都可以调用。
```
如上代码可以看到。create_id方法，由于它内部的代码并没有使用到类和对象。所以它就应该是一个非绑定方法。并且非绑定方法，类和对象都可以使用。通过在构造函数中，self.id = self.create_id()
的方式。每次实例化对象时，都会使用create_id方法生成一个对象的id属性。
# 总结
所以使用这些方法时，需要根据实际方法的编写情况。
- 如方法中，需要有对象的存在。那就使用绑定对象的方法。既，不使用装饰器的函数属性
- 如方法中，需要有类的存在。那就使用绑定类的方法。既，使用classmethod装饰器的函数属性
- 如方法中，不需要类、对象的存在。那就使用非绑定方法。既，使用staticmethod装饰器的函数属性

# 一、前言
 test.py
import test as ss

ss.f1()
ss.f2()
print(ss.a)
　我们要导入另外一个模块,可以使用import.现在有这样的需求,我动态输入一个模块名，可以随时访问到导入模块中的方法或者变量，怎么做呢？

    imp = input(“请输入你想导入的模块名:”)
    CC = __import__(imp) 這种方式就是通过输入字符串导入你所想导入的模块 
    CC.f1()  # 执行模块中的f1方法
 　　上面我们实现了动态输入模块名，从而使我们能够输入模块名并且执行里面的函数。但是上面有一个缺点，那就是执行的函数被固定了。那么，我们能不能改进一下，动态输入函数名，并且来执行呢？

复制代码
#dynamic.py
imp = input("请输入模块:")
dd = __import__(imp)
# 等价于import imp
inp_func = input("请输入要执行的函数：")

f = getattr(dd,inp_func，None)#作用:从导入模块中找到你需要调用的函数inp_func,然后返回一个该函数的引用.没有找到就烦会None

f() # 执行该函数
复制代码
　　上面我们就实现了，动态导入一个模块，并且动态输入函数名然后执行相应功能。

　　当然，上面还存在一点点小问题:那就是我的模块名有可能不是在本级目录中存放着。有可能是如下图存放方式：

　　

　　那么这种方式我们该如何搞定呢?看下面代码:

dd = __import__("lib.text.commons")  #这样仅仅导入了lib模块
dd = __import__("lib.text.commons",fromlist = True)  #改用这种方式就能导入成功
# 等价于import config
inp_func = input("请输入要执行的函数：")
f = getattr(dd,inp_func)
f()

# 反射
---
反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。
这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。

在python中面向对象的反射的体现，就是通过字符串的形式操作到对象的属性(python中任何东西都是一个对象)。如何理解这句话？有时可能需要通过用户输入的字符串，
来调用对象的方法。但默认，程序是无法通过直接输入的字符串来调用方法的。所以需要使用反射来进行操作。
python中使用如下四个函数来进行反射。下列的函数，适合类、对象还有模块导入：
- 检查一个对象中是否有指定的方法或熟悉
hasattr(obj/class, 'name'') # 返回一个布尔值。判断obj__dict__下有没有name这个key。
拿到一个对象的属性：
getattr(obj/class, 'name',None)
None当没有name属性时。返回None，而不是报错。
设置一个对象的属性
setattr(obj/class,'sex','male'')
删除一个对象的属性
delattr(obj/class,'age')
## 四个方法的演示
```python
class BlackMedium:
    feature='Ugly'
    def __init__(self,name,addr):
        self.name=name
        self.addr=addr

    def sell_house(self):
        print('%s 黑中介卖房子啦,傻逼才买呢,但是谁能证明自己不傻逼' %self.name)
    def rent_house(self):
        print('%s 黑中介租房子啦,傻逼才租呢' %self.name)

b1=BlackMedium('万成置地','回龙观天露园')

#检测是否含有某属性
print(hasattr(b1,'name'))
print(hasattr(b1,'sell_house'))

#获取属性
n=getattr(b1,'name')
print(n)
func=getattr(b1,'rent_house')
func()

# getattr(b1,'aaaaaaaa') #报错
print(getattr(b1,'aaaaaaaa','不存在啊'))

#设置属性
setattr(b1,'sb',True)
setattr(b1,'show_name',lambda self:self.name+'sb')
print(b1.__dict__)
print(b1.show_name(b1))

#删除属性
delattr(b1,'addr')
delattr(b1,'show_name')
delattr(b1,'show_name111')#不存在,则报错

print(b1.__dict__)
```
在类中的使用：
```python
class Foo(object):

    staticField = "old boy"

    def __init__(self):
        self.name = 'wupeiqi'

    def func(self):
        return 'func'

    @staticmethod
    def bar():
        return 'bar'

print getattr(Foo, 'staticField')
print getattr(Foo, 'func')
print getattr(Foo, 'bar')
```
在模块中使用
反射当前模块成员

#!/usr/bin/env python
# -*- coding:utf-8 -*-

import sys


def s1():
    print 's1'


def s2():
    print 's2'


this_module = sys.modules[__name__]

hasattr(this_module, 's1')
getattr(this_module, 's2')
导入其他模块，利用反射查找该模块是否存在某个方法
module_test.py
#!/usr/bin/env python
# -*- coding:utf-8 -*-

"""
程序目录：
    module_test.py
    index.py

当前文件：
    index.py
"""

import module_test as obj

#obj.test()

print(hasattr(obj,'test'))

getattr(obj,'test')()
# 反射的用法
---
我们来看一下反射在实际项目中的使用方法。我们假设自己编写一个ftp的客户端，它支持get、put文件。并且提供用户输入的get、put方式去执行对应的方法。
```python
class FTP_client:
    def __init__(self, ip, port, user, password):  # 定义一个IP、端口、用户、密码的构建函数
        self.ip = ip
        self.port = port
        self.user = user
        self.password = password

    def __check(self):  # 也可以定义各一个检查的封装函数,只在类的内部使用所以镜像了封装。进行密码规范的检查。这里就不详细展开了。
        pass

    def run(self):  # 运行方法。每个实例调用一个run方法来执行ftp客户端的登录。
        while True:
            inp = input('cmd > ')
            cmds = inp.split()
            if hasattr(self, cmds[0]):  # 检查对象中是否有用户输入的方法。
                func = getattr(self, cmds[0])  # 如果有的话，获取该方法
                func(cmds)  # 并执行该方法
            else:
                print('Command error')

    def get(self, cmds):
        print('Start! get %s' % cmds[1])

    def put(self, cmds):
        print('Start! put %s' % cmds[1])


ftp1 = FTP_client('10.1.1.1',22,'henry','henry')
ftp1.run()
```



#使用反射的好处
---
- 实现可插拔机制
有俩程序员，一个lili，一个是egon，lili在写程序的时候需要用到egon所写的类，但是egon去跟女朋友度蜜月去了，还没有完成他写的类，lili想到了反射，使用了反射机制lili可以继续完成自己的代码，等egon度蜜月回来后再继续完成类的定义并且去实现lili想要的功能。
总之反射的好处就是，可以事先定义好接口，接口只有在被完成后才会真正执行，这实现了即插即用，这其实是一种‘后期绑定’，什么意思？即你可以事先把主要的逻辑写好（只定义接口），然后后期再去实现接口的功能
egon还没有实现全部功能
class FtpClient:
    'ftp客户端,但是还么有实现具体的功能'
    def __init__(self,addr):
        print('正在连接服务器[%s]' %addr)
        self.addr=addr
不影响lili的代码编写
#from module import FtpClient
f1=FtpClient('192.168.1.1')
if hasattr(f1,'get'):
    func_get=getattr(f1,'get')
    func_get()
else:
    print('---->不存在此方法')
    print('处理其他的逻辑')
    
- 动态导入模块（基于反射当前模块成员）
ython提供了一个特殊的方法：__import__(字符串参数)。通过它，我们就可以实现类似的反射功能。__import__()方法会根据参数，动态的导入同名的模块。

我们再修改一下上面的visit模块的代码。

def run():
  inp = input("请输入您想访问页面的url： ").strip()
  modules, func = inp.split("/")
  obj = __import__(modules)
  if hasattr(obj, func):
    func = getattr(obj, func)
    func()
  else:
    print("404")
  
if __name__ == '__main__':
  run()
  
  
# 内置方法
一 isinstance(obj,cls)和issubclass(sub,super)
isinstance(obj,cls)检查是否obj是否是类 cls 的对象
```python
class Foo(object):
    pass
obj = Foo()
isinstance(obj, Foo)
```
issubclass(sub, super)检查sub类是否是 super 类的派生类
```python
class Foo(object):
    pass
class Bar(Foo):
    pass
issubclass(Bar, Foo)
```

三 __setattr__,__delattr__,__getattr__
三者的用法演示
```python
class Foo:
    x=1
    def __init__(self,y):
        self.y=y

    def __getattr__(self, item):
        print('----> from getattr:你找的属性不存在')


    def __setattr__(self, key, value):
        print('----> from setattr')
        # self.key=value #这就无限递归了,你好好想想
        # self.__dict__[key]=value #应该使用它

    def __delattr__(self, item):
        print('----> from delattr')
        # del self.item #无限递归了
        self.__dict__.pop(item)

#__setattr__添加/修改属性会触发它的执行
f1=Foo(10)
print(f1.__dict__) # 因为你重写了__setattr__,凡是赋值操作都会触发它的运行,你啥都没写,就是根本没赋值,除非你直接操作属性字典,否则永远无法赋值
f1.z=3
print(f1.__dict__)

#__delattr__删除属性的时候会触发
f1.__dict__['a']=3#我们可以直接修改属性字典,来完成添加/修改属性的操作
del f1.a
print(f1.__dict__)

#__getattr__只有在使用点调用属性且属性不存在的时候才会触发
f1.xxxxxx
```
七 __setitem__,__getitem__,__delitem__
将对象的属性定制成以一种字典形态进行增、删、改的python1内置方法。
```python
class Foo:
    def __init__(self,name):
        self.name=name

    def __getitem__(self, item):
        print(self.__dict__[item])

    def __setitem__(self, key, value):
        self.__dict__[key]=value
    def __delitem__(self, key):
        print('del obj[key]时,我执行')
        self.__dict__.pop(key)
    def __delattr__(self, item):
        print('del obj.key时,我执行')
        self.__dict__.pop(item)

f1=Foo('sb')
f1['age']=18
f1['age1']=19
del f1.age1
del f1['age']
f1['name']='alex'
print(f1.__dict__)
```
八 __str__,__repr__,__format__
改变对象的字符串显示__str__,__repr__
自定制格式化字符串__format__
```python
#_*_coding:utf-8_*_
__author__ = 'Linhaifeng'
format_dict={
    'nat':'{obj.name}-{obj.addr}-{obj.type}',#学校名-学校地址-学校类型
    'tna':'{obj.type}:{obj.name}:{obj.addr}',#学校类型:学校名:学校地址
    'tan':'{obj.type}/{obj.addr}/{obj.name}',#学校类型/学校地址/学校名
}
class School:
    def __init__(self,name,addr,type):
        self.name=name
        self.addr=addr
        self.type=type

    def __repr__(self):
        return 'School(%s,%s)' %(self.name,self.addr)
    def __str__(self):
        return '(%s,%s)' %(self.name,self.addr)

    def __format__(self, format_spec):
        # if format_spec
        if not format_spec or format_spec not in format_dict:
            format_spec='nat'
        fmt=format_dict[format_spec]
        return fmt.format(obj=self)

s1=School('oldboy1','北京','私立')
print('from repr: ',repr(s1))
print('from str: ',str(s1))
print(s1)

'''
str函数或者print函数--->obj.__str__()
repr或者交互式解释器--->obj.__repr__()
如果__str__没有被定义,那么就会使用__repr__来代替输出
注意:这俩方法的返回值必须是字符串,否则抛出异常
'''
print(format(s1,'nat'))
print(format(s1,'tna'))
print(format(s1,'tan'))
print(format(s1,'asfdasdffd'))
```
十三 __del__
我们知道了__init__是构造方法，哪__del__是析构方法。它的作用是，当对象在内存中被释放时，自动触发执行。
可以通过使用它，在实例从内存中删除时进行一些操作。
注：如果产生的对象仅仅只是python程序级别的（用户级），那么无需定义__del__,如果产生的对象的同时还会向操作系统发起系统调用，
即一个对象有用户级与内核级两种资源，比如（打开一个文件，创建一个数据库链接），则必须在清除对象的同时回收系统资源，这就用到了__del__。
简单示范
```python
class Foo:

    def __del__(self):
        print('执行我啦')

f1=Foo()
del f1
print('------->')

#输出结果
执行我啦
------->
挖坑埋了你
class Foo:

    def __del__(self):
        print('执行我啦')

f1=Foo()
# del f1
print('------->')

#输出结果
------->
执行我啦


#为何啊？？？
```

典型的应用场景：
创建数据库类，用该类实例化出数据库链接对象，对象本身是存放于用户空间内存中，而链接则是由操作系统管理的，存放于内核空间内存中
当程序结束时，python只会回收自己的内存空间，即用户态内存，而操作系统的资源则没有被回收，这就需要我们定制__del__，在对象被删除前向操作系统发起关闭数据库链接的系统调用，回收资源+

这与文件处理是一个道理：
f=open('a.txt') #做了两件事，在用户空间拿到一个f变量，在操作系统内核空间打开一个文件
del f #只回收用户空间的f，操作系统的文件还处于打开状态

#所以我们应该在del f之前保证f.close()执行,即便是没有del，程序执行完毕也会自动del清理资源，于是文件操作的正确用法应该是
f=open('a.txt')
读写...
f.close()
很多情况下大家都容易忽略f.close,这就用到了with上下文管理
总结
- python中以__XXX__格式的内置方法，会在某种情况下自动触发执行。帮助将程序中的类进行定制化

# 元类
## 前言(exec函数)

二 引子（类也是对象）
python中一切皆是对象,如何去深入理解这句话？符合如下4个规范的就是一个对象：
1. 赋值给一个变量。X = obj
2. 作为函数参数进行传递
3. 作为函数的返回值
4. 可以作为容器类的元素。列表中可以放函数、模块、等l=[func, time,]

我们来看一下类是否符合这4个规范
1. 把类赋值给一个变量
2. 把类作为函数参数进行传递
3. 把类作为函数的返回值
4. 在运行时动态地创建类
所以类也是一个对象。当使用关键字class的时候，python解释器在加载class的时候就会创建一个对象(这里的对象指的是类而非类的实例)，因而我们可以将类当作一个对象去使用
```python
class Foo:
      pass

f1=Foo() #f1是通过Foo类实例化的对象
print(type(obj))  # 由Foo类实例化而来
print(type(Foo))   # 由type类实例化而来 Foo=type(...)
```

上例可以看出f1是由Foo这个类产生的对象，而Foo本身也是对象，那它又是由哪个类产生的呢？
#type函数可以查看类型，也可以用来查看对象的类，二者是一样的
print(type(f1)) # 输出：<class '__main__.Foo'> 表示，obj 对象由Foo类创建
print(type(Foo)) # 输出：<type 'type'>

我们发现type这个类是一个制造类的类。所以这里经引出了元类，元类就是一个制造类的类。所以type类就是python中其他类的元类。

# 元类
产生类的类称之为元类，默认所有用class定义的类，的元类都是type类。
#＃　创建类的两种方式：
在讲解创建元类前。我们先来看一下创建类的两种方式
1. 方式一：class
```python
class Chinese(object):
    country='China'
    def __init__(self,name,age):
        self.name=name
        self.age=age
    def talk(self):
        print('%s is talking' %self.name)
```
2. 方式二：就是手动模拟class创建类的过程）：将创建类的步骤拆分开，用type函数去创建类
定义类的三要素：
1. 类名
2. 继承的父类
3. 类体代码
```python
#类名
class_name='Chinese'
#类的父类
class_bases=(object,)
#类体
class_body="""
country='China'
def __init__(self,name,age):
    self.name=name
    self.age=age
def talk(self):
    print('%s is talking' %self.name)
"""
```
步骤一（先处理类体->名称空间）：类体定义的名字都会存放于类的名称空间中（一个局部的名称空间），我们可以事先定义一个空字典，然后用exec去执行类体的代码（exec产生名称空间的过程与真正的class过程类似，只是后者会将__开头的属性变形），生成类的局部名称空间，即填充字典
```python
class_dic={}
exec(class_body ,globals(), class_dic)
print(class_dic)
#{'country': 'China', 'talk': <function talk at 0x101a560c8>, '__init__': <function __init__ at 0x101a56668>}
```

步骤二：调用元类type（也可以自定义）来产生类Chinense
```python
Chinese=type(class_name,class_bases,class_dic) #实例化type得到对象Chinese，即我们用class定义的类Foo


print(Foo)
print(type(Foo))
print(isinstance(Foo,type))
'''
<class '__main__.Chinese'>
<class 'type'>
True
'''
```

我们看到，type 接收三个参数：
第 1 个参数是字符串 class_name，表示类名
第 2 个参数是元组 (object, )，表示所有的父类
第 3 个参数是字典，这里是一个空字典，表示没有定义属性和方法
补充：若Foo类有继承，即class Foo(Bar):.... 则等同于type('Foo',(Bar,),{})

这两种类实例化后的结果都是一样的。

# 自定义元类控制类的创建
使用自己创建的元类对类的创建进行一定的控制。
如下代码通过自己创建一个Mymeta的元类，来控制其他类的命名规范和注释规范
```python
#步骤一：如果说People=type(类名,类的父类们,类的名称空间)，那么我们定义元类如下，来控制类的创建
class Mymeta(type):  # 需要去继承type元类的属性
    def __init__(self, class_name, class_bases, class_dic):
        if '__doc__' not in class_dic or not class_dic.get('__doc__').strip():  # 类的主体必须有注释
            raise TypeError('必须为类指定文档注释')

        if not class_name.istitle():  # 类的名字必须大小写
            raise TypeError('类名首字母必须大写')

        super(Mymeta, self).__init__(class_name, class_bases, class_dic)  # 重用父类type类的构造方法


# class People(object, metaclass=Mymeta) 等于People = Mymeta(class_name, class_bases, class_dic)
class People(object, metaclass=Mymeta):
    country = 'China'

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def talk(self):
        print('%s is talking' % self.name)
```

# 自定义元类控制实例化行为

#储备知识__call__方法的使用
我们知道使用obj=class(）语句，可以调用类来实例化一个对象。哪这里就有一个疑问。python中一切皆对象，obj也是一个对象，哪它是否可以被调用哪？
我们来看一下如下代码obj是否可以被调用：
#### 代码部分
```python
class Foo:
    pass


obj = Foo()
obj()
```
#### 输出内容
```text
Traceback (most recent call last):
  File "I:/python_project/first-app/homework/test.py", line 5, in <module>
    obj()
TypeError: 'Foo' object is not callable
```
可以发现程序报错了，所Foo的对象没有调用的能力。哪obj是否就打破了python中一切皆对象的定义，它不是一个对象哪？并不是，使用__call__方法就可以让obj对象可以被调用。如下代码。
```python
class People(object,metaclass=type):
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def __call__(self, *args, **kwargs):
        print(self,args,kwargs)


# 调用类People，并不会出发People类的__call__方法
obj=People('egon',18)

# 调用对象obj(1,2,3,a=1,b=2,c=3)，才会触发对象的绑定方法obj.__call__(1,2,3,a=1,b=2,c=3)
obj(1,2,3,a=1,b=2,c=3) #打印：<__main__.People object at 0x10076dd30> (1, 2, 3) {'a': 1, 'b': 2, 'c': 3}
```
如上代码，就可以让obj对象支持被调用了。但是光讲这样一个实例是没有多大意义的，现在回想一下调用类并实例化对象的obj=People('egon',18)语句。
那再来看一下实例化对象时的语句obj=People('egon',18)。People类的元类是type类，那么People类也是type类的实例化后的对象。所以在元类type内肯定也有一个__call__，会在调用People('egon',18)时触发执行，然后返回一个初始化好了的对象obj。
所以我们也可以在自定义的元类中使用__call__方法来控制类的调用（实例化）过程中的操作（当然，不在自定义的元类中使用__call__方法也不会影响，会去使用自定义元类继承type元类中的__call__方法）。
如我们需要在自定义的元类中使用__call__方法，需要注意的是，类的调用时需要做哪些事情哪？这些需要做的事情，必须要在__call__方法内部实现的
1. 实例化对象，产生空对象obj
2. 调用People下的函数__init__，初始化obj
3. 返回初始化好了的obj
如下代码，就可以看到在自定义的元类中如何写__call__方法。
```python
#步骤三：自定义元类，控制类的调用（即实例化）的过程
class Mymeta(type): #继承默认元类的一堆属性
    def __init__(self,class_name,class_bases,class_dic):
        if not class_name.istitle():
            raise TypeError('类名首字母必须大写')

        super(Mymeta,self).__init__(class_name,class_bases,class_dic)

    def __call__(self, *args, **kwargs):
        #self=People
        print(self,args,kwargs) #<class '__main__.People'> ('egon', 18) {}

        #1、实例化People，产生空对象obj
        obj=object.__new__(self)


        #2、调用People下的函数__init__，初始化obj
        self.__init__(obj,*args,**kwargs)


        #3、返回初始化好了的obj
        return obj

class People(object,metaclass=Mymeta):
    country='China'

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def talk(self):
        print('%s is talking' %self.name)

obj=People('egon',18)  # People.__call__（People, 'egon', 18）
print(obj.__dict__) #{'name': 'egon', 'age': 18}

#步骤四：
class Mymeta(type): #继承默认元类的一堆属性
    def __init__(self,class_name,class_bases,class_dic):
        if not class_name.istitle():
            raise TypeError('类名首字母必须大写')

        super(Mymeta,self).__init__(class_name,class_bases,class_dic)

    def __call__(self, *args, **kwargs):
        #self=People
        print(self,args,kwargs) #<class '__main__.People'> ('egon', 18) {}

        #1、调用self，即People下的函数__new__，在该函数内完成：1、产生空对象obj 2、初始化 3、返回obj
        obj=self.__new__(self,*args,**kwargs)

        #2、一定记得返回obj，因为实例化People(...)取得就是__call__的返回值
        return obj

class People(object,metaclass=Mymeta):
    country='China'

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def talk(self):
        print('%s is talking' %self.name)

    def __new__(cls, *args, **kwargs):
        obj=object.__new__(cls)
        cls.__init__(obj,*args,**kwargs)
        return obj

obj=People('egon',18)
print(obj.__dict__) #{'name': 'egon', 'age': 18}
```
单例模式
单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。
当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。

我们知道，使用类创建每一个对象的内存空间都不相同。哪这有一个问题。就是当实例化过多对象后，会导致内存空间资源的严重浪费。

比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，
有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，
而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。

在python中的非可变数据类型的变量赋值就是一个单例模式。如下实例：
#### 代码部分
```python
x = 1
y = 1
print(id(x),id(y))
```
#### 输出部分
```python
9326752 9326752
```
x = 1和y = 1等于 x = int(1)和y=int(1)，就是使用int类创建了一个x，y的实例。我们会发现两个对象如果数值是一样的话，内存的id都指向一个内存空间。这就是单例模式。

使用类的函数属性的方式实现单例模式。
```python
#步骤五：基于元类实现单例模式,比如数据库对象,实例化时参数都一样,就没必要重复产生对象,浪费内存
class Mysql:
    __instance=None  # 创建一个类的内部属性
    def __init__(self,host='127.0.0.1',port='3306'):
        self.host=host
        self.port=port

    # 创建一个绑定到类的方法。这方法，会判断类的内部属性__instance是否有值。如果没有值的话，使用自己的类进行实例化，并赋值给自己类的内部属性__instance。
    # 如果__instance已经有值，直接返回值。
    @classmethod  # 创建一个绑定给类的方法
    def singleton(cls,*args,**kwargs): 
        if not cls.__instance:  # 如果类的内部属性__instance没有值。
            cls.__instance=cls(*args,**kwargs)  # 使用cls类实例化一个为对象。并将这个对象赋值给类的__instance属性
        return cls.__instance  # 返回cls.__instance属性。
    # 通过如上方法，以后无论Mysql类实例化了多少对象，最后返回给对象的内存地址都是__instance属性中对象的内存地址。
    
obj1=Mysql()
obj2=Mysql()
print(obj1 is obj2) #False

obj3=Mysql.singleton()
obj4=Mysql.singleton()
print(obj3 is obj4) #True
```
元类方式实现单例模式
```python
class Mymeta(type):
    def __init__(self,name,bases,dic): #定义类Mysql时就触发
        self.__instance=None
        super().__init__(name,bases,dic)

    def __call__(self, *args, **kwargs): #Mysql(...)时触发

        if not self.__instance:
            self.__instance=object.__new__(self) #产生空对象，并赋值给self.__instance
            self.__init__(self.__instance,*args,**kwargs) #初始化对象
            #上述两步可以合成下面一步
            # self.__instance=super().__call__(*args,**kwargs)

        return self.__instance
class Mysql(metaclass=Mymeta):
    def __init__(self,host='127.0.0.1',port='3306'):
        self.host=host
        self.port=port


obj1=Mysql()
obj2=Mysql()

print(obj1 is obj2)
```
六 练习题
练习一：在元类中控制把自定义类的数据属性都变成大写。
练习二：在元类中控制自定义的类无需init方法
1.元类帮其完成创建对象，以及初始化操作；
　　2.要求实例化时传参必须为关键字形式，否则抛出异常TypeError: must use keyword argument
　　3.key作为用户自定义类产生对象的属性，且所有属性变成大写

# 面向对象的软件开发
https://triaquae.gitbooks.io/python/content/di-5-zhang-mian-xiang-dui-xiang-bian-cheng-she-ji-yu-kai-fa/511-mian-xiang-dui-xiang-de-ruan-jian-kai-fa.html
https://triaquae.gitbooks.io/python/content/di-5-zhang-mian-xiang-dui-xiang-bian-cheng-she-ji-yu-kai-fa/511-mian-xiang-dui-xiang-de-ruan-jian-kai-fa/ling-yu-mo-xing.html
http://www.cnblogs.com/linhaifeng/articles/7341318.html

# 异常处理
## 一、什么是异常
异常就是程序运行时发生错误的信号（在程序出现错误时，则会产生一个异常，若程序没有处理它，则会抛出该异常，程序的运行也随之终止）。异常有如下特性：
- 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。异常作为事件，不需要在程序里传送结果标志或显式地测试它们。
- 异常是Python对象，表示一个错误。异常可以作为类被定义, 也可以人为引发异常.
- 异常可以作为控制流, 通过异常情况或人为引发异常, 可以执行代码流控制, 实现比较高级的”goto”效果. 例如在for循环内引发错误,可以跳到外面几层的某个try..except内.

## 二、错误分成两种
1.语法错误（这种错误，根本过不了python解释器的语法检测，必须在程序执行前就改正）
```python
#语法错误示范一
if
#语法错误示范二
def test:
    pass
#语法错误示范三
class Foo
    pass
#语法错误示范四
print(haha)
```

2.逻辑错误
```python
#TypeError:int类型不可迭代
for i in 3:
    pass
#ValueError
num=input(">>: ") #输入hello
int(num)

#NameError
aaa

#IndexError
l=['egon','aa']
l[3]

#KeyError
dic={'name':'egon'}
dic['age']

#AttributeError
class Foo:pass
Foo.x

#ZeroDivisionError:无法完成计算
res1=1/0
res2=1+'str'
```
## 二 异常的种类
在python中不同的异常可以用不同的类型（python中统一了类与类型，类型即类）去标识，一个异常标识一种错误
常见异常：
AttributeError 试图访问一个对象没有的属性，比如foo.x，但是foo没有属性x
IOError 输入/输出异常；基本上是无法打开文件
ImportError 无法引入模块或包；基本上是路径问题或名称错误
IndentationError 语法错误（的子类） ；代码没有正确对齐
IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]
KeyError 试图访问字典里不存在的键
KeyboardInterrupt Ctrl+C被按下
NameError 使用一个还未被赋予对象的变量
SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）
TypeError 传入对象类型与要求的不符合
UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，
导致你以为正在访问它
ValueError 传入一个调用者不期望的值，即使值的类型是正确的
----

异常名称	描述
BaseException	所有异常的基类
SystemExit	解释器请求退出
KeyboardInterrupt	用户中断执行(通常是输入^C)
Exception	常规错误的基类
StopIteration	迭代器没有更多的值
GeneratorExit	生成器(generator)发生异常来通知退出
StandardError	所有的内建标准异常的基类
ArithmeticError	所有数值计算错误的基类
FloatingPointError	浮点计算错误
OverflowError	数值运算超出最大限制
ZeroDivisionError	除(或取模)零 (所有数据类型)
AssertionError	断言语句失败
AttributeError	对象没有这个属性
EOFError	没有内建输入,到达EOF 标记
EnvironmentError	操作系统错误的基类
IOError	输入/输出操作失败
OSError	操作系统错误
WindowsError	系统调用失败
ImportError	导入模块/对象失败
LookupError	无效数据查询的基类
IndexError	序列中没有此索引(index)
KeyError	映射中没有这个键
MemoryError	内存溢出错误(对于Python 解释器不是致命的)
NameError	未声明/初始化对象 (没有属性)
UnboundLocalError	访问未初始化的本地变量
ReferenceError	弱引用(Weak reference)试图访问已经垃圾回收了的对象
RuntimeError	一般的运行时错误
NotImplementedError	尚未实现的方法
SyntaxError	Python 语法错误
IndentationError	缩进错误
TabError	Tab 和空格混用
SystemError	一般的解释器系统错误
TypeError	对类型无效的操作
ValueError	传入无效的参数
UnicodeError	Unicode 相关的错误
UnicodeDecodeError	Unicode 解码时的错误
UnicodeEncodeError	Unicode 编码时错误
UnicodeTranslateError	Unicode 转换时错误
Warning	警告的基类
DeprecationWarning	关于被弃用的特征的警告
FutureWarning	关于构造将来语义会有改变的警告
OverflowWarning	旧的关于自动提升为长整型(long)的警告
PendingDeprecationWarning	关于特性将会被废弃的警告
RuntimeWarning	可疑的运行时行为(runtime behavior)的警告
SyntaxWarning	可疑的语法的警告
UserWarning	用户代码生成的警告

更多异常

ArithmeticError
AssertionError
AttributeError
BaseException
BufferError
BytesWarning
DeprecationWarning
EnvironmentError
EOFError
Exception
FloatingPointError
FutureWarning
GeneratorExit
ImportError
ImportWarning
IndentationError
IndexError
IOError
KeyboardInterrupt
KeyError
LookupError
MemoryError
NameError
NotImplementedError
OSError
OverflowError
PendingDeprecationWarning
ReferenceError
RuntimeError
RuntimeWarning
StandardError
StopIteration
SyntaxError
SyntaxWarning
SystemError
SystemExit
TabError
TypeError
UnboundLocalError
UnicodeDecodeError
UnicodeEncodeError
UnicodeError
UnicodeTranslateError
UnicodeWarning
UserWarning
ValueError
Warning
ZeroDivisionError

##Python内建异常体系结构
BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StandardError
      |    +-- BufferError
      |    +-- ArithmeticError
      |    |    +-- FloatingPointError
      |    |    +-- OverflowError
      |    |    +-- ZeroDivisionError
      |    +-- AssertionError
      |    +-- AttributeError
      |    +-- EnvironmentError
      |    |    +-- IOError
      |    |    +-- OSError
      |    |         +-- WindowsError (Windows)
      |    |         +-- VMSError (VMS)
      |    +-- EOFError
      |    +-- ImportError
      |    +-- LookupError
      |    |    +-- IndexError
      |    |    +-- KeyError
      |    +-- MemoryError
      |    +-- NameError
      |    |    +-- UnboundLocalError
      |    +-- ReferenceError
      |    +-- RuntimeError
      |    |    +-- NotImplementedError
      |    +-- SyntaxError
      |    |    +-- IndentationError
      |    |         +-- TabError
      |    +-- SystemError
      |    +-- TypeError
      |    +-- ValueError
      |         +-- UnicodeError
      |              +-- UnicodeDecodeError
      |              +-- UnicodeEncodeError
      |              +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
       +-- ImportWarning
       +-- UnicodeWarning
       +-- BytesWarning
##三 异常处理
为了保证程序的健壮性与容错性，即在遇到错误时程序不会崩溃，我们需要对异常进行处理，
如果错误发生的条件是可预知的，我们需要用if进行处理：在错误发生之前进行预防
```python
AGE=10
while True:
    age=input('>>: ').strip()
    if age.isdigit(): #只有在age为字符串形式的整数时,下列代码才不会出错,该条件是可预知的
        age=int(age)
        if age == AGE:
            print('you got it')
            break
```
如果错误发生的条件是不可预知的，则需要用到try...except：在错误发生之后进行处理
```python
#基本语法为
try:
    被检测的代码块
except 异常类型：
    try中一旦检测到异常，就执行这个位置的逻辑
#举例
try:
    f=open('a.txt')
    g=(line.strip() for line in f)
    print(next(g))
    print(next(g))
    print(next(g))
    print(next(g))
    print(next(g))
except StopIteration:
    f.close()
```
这里所说的异常处理都是围绕着不可预知的情况下的异常处理。
异常处理无外乎几件事: 断言(assert)和抛错(raise), 检查(try), 捕获(except), 处理(except,else,finally).

## 异常处理语句
# try语句
try语句用来检测异常。try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，
try子句先执行，接下来会发生什么依赖于执行时是否出现异常。try语句有两种模式,try..except..else和try..finally.

# try..except..else
```text
try:
	<statement>        #运行别的代码
except <name>：        # <name>定义异常类型
	<statement>        #如果在try中的语句符合了<name>异常，则会执行except中的<statement>语句
else:
	<statement>        #如果没有异常发生，则会执行else中的<statement>语句
```
当try后的语句执行时发生异常，python会首先匹配try语句中的异常类型是否与except子句中<name>设置的异常类型一致，如一致执行except语句中的代码部分，
如果异常类型没有匹配的except子句中<name>定义的异常类型，python解释器会抛出异常，并结束程序。
当异常处理完毕后，控制流就执行完整个try语句。
如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。
except语句有几种形式,包括捕获所有异常的except:和except Exception  ,某个异常的except ErrorName:或几种异常except (Error1,Error2,Error3):, except Error as e: 可以将异常类的值传给变量e,收集作为异常处理语句中的数据进行处理.
1.异常类只能用来处理指定的异常情况，如果非指定异常则无法处理
s1 = 'hello'
try:
    int(s1)
except IndexError as e: # 未捕获到异常，程序直接报错
    print e
2.except多分支
代码中抛出的异常有多种可能性，针对每一种异常类型，定制自己except语句与异常处理逻辑。
```python
s1 = 'hello'
try:
    int(s1)
except IndexError as e:
    print(e)
except KeyError as e:
    print(e)
except ValueError as e:
    print(e)
```

   
3.万能异常Exception。
所有的异常都使用一种处理逻辑的话，可以会用万能异常。
```python
s1 = 'hello'
try:
    int(s1)
except Exception as e:
    print(e)
```
万能异常的也可以放在在多分支的最后。需要特殊处理的异常用except <name>语句单独定义，可以统一处理的异常使用万能异常一起处理。
 ```python
s1 = 'hello'
try:
    int(s1)
except IndexError as e:
    print(e)
except KeyError as e:
    print(e)
except ValueError as e:
    print(e)
except Exception as e:
    print(e)   
```

    
# try..finally
```text
try:
	<statement>        #运行代码
finally:
	<statement>        #不管有无异常都会执行
```
如果try语句中的代码没有异常就先运行try中的代码,再运行finally中的代码，如果try语句检测到自己代码中有异常后，会抛出异常，然后再finally中的代码。
finally可以在except/else后。优先先执行except/else再执行finally。
```python
s1 = 'hello'
try:
    int(s1)
except IndexError as e:
    print(e)
except KeyError as e:
    print(e)
except ValueError as e:
    print(e)
#except Exception as e:
#    print(e)
else:
    print('try内代码块没有异常则执行我')
finally:
    print('无论异常与否,都会执行该模块,通常是进行清理工作')
```
使用try..finally语句适合在无论是否发生异常都需要对系统资源进行回收的场景。

##raise语句
raise语句可以主动抛出某个异常来被try捕获. 更常用于结合if等进行条件检查.例如某变量假定[0,10],<0时抛出一个错,>10抛出另一个错误.
语法：
```python
raise [Exception [, args [, traceback]]]
```
语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。
raise语句在执行的时候回使用Exception定义的异常类型（异常类）实例化一个对象，并打印这个对象。
```python
try:
	if (i>10):
		raise TypeError(i)
	elif (i<0):
		raise ValueError,i
#下面的e实际是返回错误的对象实例.
except TypeError,e:
	print str(e)+" for i is larger than 10!"
except ValueError,e:
	print str(e)+" for i is less than 0!"
else:
	print "i is between 0 and 10~"
```

## 断言assert语句
Python的assert是用来检查一个条件，如果它为真，就不做任何事。如果它为假，则会抛出AssertError并且包含错误信息。
```text
assert expression[,argument]
```
表达式部分返回真/假, argument部分一般是引发时传递的标示,一般用于输出,或者进一步用于控制。
断言一般用于在调试的时候使用。在调试章节中，我们将详细讲解。断言的详细用法。
```python
assert 1 == 0,'one does not equal zero'
```

## 自定义异常类。
7.自定义异常类型，定义异常类型
```python
class EgonException(BaseException):
    def __init__(self,msg):
        super(EgonException, self).__init__()
        self.msg=msg
        
    def __str__(self):
        return self.msg

raise EgonException('类型错误')
```

##异常的嵌套使用
由此可知, try…finally 模式更适合于嵌套在try..except内作为保证某些代码一定执行.因为try..except…else要是执行了except就不会执行else,无法保证某个代码必须执行.所以常见的整合模式为:

# 两种模式的嵌套和结合
try:
	<statement1>        #运行测试代码1
	try:
		<statement2>        #运行测试代码2
	finally:
		<statement3>        #不管测试代码2有无异常都会执行
except <name>：
	<statement>        #测试代码1或2发生错误而被捕获,就会执行异常
else:
	<statement>        #测试代码1和2都没有发生错误就会执行
finally:
	<statement4>        #无论两个try有无异常,都会运行一次.
PS: 要是finally在except/else前面肯定会报错.因为try后直接给finally,然后会交给上层try.但没有上层try…


9.总结try..except
1：把错误处理和真正的工作分开来
2：代码更易组织，更清晰，复杂的工作任务更容易实现；
3：毫无疑问，更安全了，不至于由于一些小的疏忽而使程序意外崩溃了； 
但是程序中，你可以预估和解决的异常尽量不要用try...except，而是去解决这个异常。只有在异常一定会发生，并且无法预估发生的情况时，才使用异常处理。

# 调试
程序能一次写完并正常运行的概率很小，基本不超过1%。总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。

第一种方法简单直接粗暴有效，就是用print把可能有问题的变量打印出来看看：

# err.py
def foo(s):
    n = int(s)
    print '>>> n = %d' % n
    return 10 / n

def main():
    foo('0')

main()
执行后在输出中查找打印的变量值：

$ python err.py
>>> n = 0
Traceback (most recent call last):
  ...
ZeroDivisionError: integer division or modulo by zero
用print最大的坏处是将来还得删掉它，想想程序里到处都是print，运行结果也会包含很多垃圾信息。所以，我们又有第二种方法。

## 1. 断言
凡是用print来辅助查看的地方，都可以用断言（assert）来替代：

# err.py
def foo(s):
    n = int(s)
    assert n != 0, 'n is zero!'
    return 10 / n

def main():
    foo('0')
assert的意思是，表达式n != 0应该是True，否则，后面的代码就会出错。

如果断言失败，assert语句本身就会抛出AssertionError：

$ python err.py
Traceback (most recent call last):
  ...
AssertionError: n is zero!
程序中如果到处充斥着assert，和print相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert：

$ python -O err.py
Traceback (most recent call last):
  ...
ZeroDivisionError: integer division or modulo by zero
关闭后，你可以把所有的assert语句当成pass来看。

## 2. pdb
pdb
第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：

# err.py
s = '0'
n = int(s)
print 10 / n
然后启动：

$ python -m pdb err.py
> /Users/michael/Github/sicp/err.py(2)<module>()
-> s = '0'
以参数-m pdb启动后，pdb定位到下一步要执行的代码-> s = '0'。输入命令l来查看代码：

(Pdb) l
  1     # err.py
  2  -> s = '0'
  3     n = int(s)
  4     print 10 / n
[EOF]
输入命令n可以单步执行代码：

(Pdb) n
> /Users/michael/Github/sicp/err.py(3)<module>()
-> n = int(s)
(Pdb) n
> /Users/michael/Github/sicp/err.py(4)<module>()
-> print 10 / n
任何时候都可以输入命令p 变量名来查看变量：

(Pdb) p s
'0'
(Pdb) p n
0
输入命令q结束调试，退出程序：

(Pdb) n
ZeroDivisionError: 'integer division or modulo by zero'
> /Users/michael/Github/sicp/err.py(4)<module>()
-> print 10 / n
(Pdb) q
这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。

pdb.set_trace()
这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点：

# err.py
import pdb

s = '0'
n = int(s)
pdb.set_trace() # 运行到这里会自动暂停
print 10 / n
运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行：

$ python err.py 
> /Users/michael/Github/sicp/err.py(7)<module>()
-> print 10 / n
(Pdb) p n
0
(Pdb) c
Traceback (most recent call last):
  File "err.py", line 7, in <module>
    print 10 / n
ZeroDivisionError: integer division or modulo by zero
这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。


#网络编程

##套接字介绍-socket
Socket套接字方法
socket 实例类(8-10分钟)
socket.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None)
family(socket家族)
socket.AF_UNIX：用于本机进程间通讯，为了保证程序安全，两个独立的程序(进程)间是不能互相访问彼此的内存的，但为了实现进程间的通讯，可以通过创建一个本地的socket来完成
socket.AF_INET:(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)
socket type类型
socket.SOCK_STREAM #for tcp
socket.SOCK_DGRAM #for udp
socket.SOCK_RAW #原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。
socket.SOCK_RDM #是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。
socket.SOCK_SEQPACKET #废弃了
(Only SOCK_STREAM and SOCK_DGRAM appear to be generally useful.)
proto=0 请忽略，特殊用途
fileno=None 请忽略，特殊用途
服务端套接字函数(2分钟)
s.bind() 绑定(主机,端口号)到套接字
s.listen() 开始TCP监听
s.accept() 被动接受TCP客户的连接,(阻塞式)等待连接的到来
客户端套接字函数(2分钟)
s.connect() 主动初始化TCP服务器连接
s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常
公共用途的套接字函数(3-5分钟)
s.recv() 接收数据
s.send() 发送数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完，可后面通过实例解释)
s.sendall() 发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)
s.recvfrom() Receive data from the socket. The return value is a pair (bytes, address)
s.getpeername() 连接到当前套接字的远端的地址
s.close() 关闭套接字
socket.setblocking(flag) #True or False,设置socket为非阻塞模式，以后讲io异步时会用
socket.getaddrinfo(host, port, family=0, type=0, proto=0, flags=0) 返回远程主机的地址信息，例子 socket.getaddrinfo('luffycity.com',80)
socket.getfqdn() 拿到本机的主机名
socket.gethostbyname() 通过域名解析ip地址

send方法与recv方法的原理
send方法会通过socket将数据发给操作系统，操作系统根据你在socket中定义的网络协议对数据进行封装，然后在通过网卡发出。
所以说send方法只是将应用程序内存的数据，传输给操作系统内存，并请求操作系统将数据根据网络协议从网卡传出。

recv方法也会通过socket请求操作系统从网卡中获取自己需要接收的数据。所以说recv方法会等待对端发过来的数据，
然后请求操作系统将操作系统内存中的数据copy到自己的应用程序内存进行处理。recv()也可以设置最大发送的字节数，这是可以从操作系统内存中拿取的最大字节数。

## socket编程基础
简单的socket编程：
1. 使用套接字编程进行服务端和客户端的连接。

```python
# server.py
import socket  # 导入socket模块

HOST = '127.0.0.1'                 # 服务器接收连接和数据的IP地址
PORT = 8080            # 服务器接收连接和数据的端口

sock_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 使用socket类创建实例。并且定义两个参数：AF_INET基于IP网络接收连接与数据，SOCK_STREAM基于TCP协议接收连接和数据
sock_server.bind((HOST, PORT))  # 绑定服务器的通信使用的IP和端口

sock_server.listen(5)  # 开始监听，5代表在允许有五个连接排队，更多的新连接连进来时就会被拒绝。
res = sock_server.accept()  # 等待客户端的连接。阻塞直到接收客户端的连接为止，有了一个新的客户端连接进来后，就会为这个请求生成一个连接对象。这个连接对象包含一个新socket和客户端的IP地址和端口。这个新的socket用来进行客户端和服务端之间的数据传输
print(res)  # 打印服务端接收客户端连接后的结果


# client.py
import socket

HOST = 'localhost'    # 服务端的IP
PORT = 8080              # 服务端的端口

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 使用socket类创建实例。并且定义两个参数：AF_INET基于IP网络接收连接与数据，SOCK_STREAM基于TCP协议接收连接和数据
client.connect((HOST, PORT))  # 连接服务端的IP和端口

```
### 输出内容
```python
(<socket.socket fd=444, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8080), raddr=('127.0.0.1', 60800)>, ('127.0.0.1', 60800))
```
如上代码，只是简单的做了一个服务端和客户端网络连接的例子，并不包含数据传输。
可以看到，服务端接收了客户端的连接，并且返回了一个元组数据。这个元组数据分为两部分：
- <socket.socket fd=444, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8080), raddr=('127.0.0.1', 60800)>：一个新的socket对象，当TCP三次握手完成后，会生成这个socket，可以用来后续的接收和发生数据。
- ('127.0.0.1', 60800) 客户端的访问IP和端口。
通过服务端accept函数返回新的socket对象。可以进行后续的数据接收和发送。

2. 使用套接字编程进行服务端和客户端的收发数据。

```python
# server.py文件
# Echo server program
import socket  # 导入socket模块

HOST = ''                 # Symbolic name meaning all available interfaces
PORT = 50007              # Arbitrary non-privileged port

sock_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 使用socket类创建实例，AF_INET基于IP网络，SOCK_STREAM基于TCP协议
sock_server.bind((HOST, PORT))  # 绑定服务器的通信使用的IP和端口

sock_server.listen(5)  #开始监听，5代表在允许有五个连接排队，更多的新连接连进来时就会被拒绝
conn, addr = sock_server.accept() #等待连接。阻塞直到接收连接为止，有了一个新连接进来后，就会为这个请求生成一个连接对象。并可以将链接成功的消息赋值给变量

print('Connected by', addr)
data = conn.recv(1024) #接收1024个字节。单位bytes。1024是最大接收的限制。
conn.sendall(b'welcome') #把收到的数据再全部返回给客户端

conn.close()  # 关闭客户端的连接
sock_server.close()  # 关闭服务端的socket

# client.py文件
# Echo client program
import socket

HOST = 'localhost'    # The remote host
PORT = 50007              # The same port as used by the server

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((HOST, PORT))  # 连接服务端的IP和端口
client.sendall(b'Hello, world')  # 发送数据

data = client.recv(1024)

print('Received',data)

client.close()  # 关闭客户端的socket
```
需要注意的是，
1. 由于socket传输使用的是bytes字节。所以需要将字符串编码成bytes格式才可以在网络中传输。可以通过两种方式进行编码：
- b'Hello, world'
- 'Hello, world'.encode('utf-8')
2. 当服务端和客户端数据传输完成后，我们需要手工的关闭，服务端和客户端的所有socket。关闭socket的两种方法：
- socket.close() 手工关闭socket
- 使用with语句自动关闭socket
```python
# server.py文件
import socket  # 导入socket模块

HOST = ''                 # Symbolic name meaning all available interfaces
PORT = 50007              # Arbitrary non-privileged port

sock_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 使用socket类创建实例，AF_INET基于IP网络，SOCK_STREAM基于TCP协议
with sock_server:  # 完成后关闭连接socket
    sock_server.bind((HOST, PORT))  # 绑定服务器的通信使用的IP和端口

    sock_server.listen(5)  #开始监听，5代表在允许有五个连接排队，更多的新连接连进来时就会被拒绝
    conn, addr = sock_server.accept() #等待连接。阻塞直到接收连接为止，有了一个新连接进来后，就会为这个请求生成一个连接对象。并可以将链接成功的消息赋值给变量

    print('Connected by', addr)
    with conn:  # 完成后自动关闭数据接收socket
        data = conn.recv(1024) #接收1024个字节。单位bytes。1024是最大接收的限制。
        conn.sendall(b'welcome') #把收到的数据再全部返回给客户端

# client.py文件
import socket

HOST = 'localhost'    # The remote host
PORT = 50007              # The same port as used by the server

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
with client:  # 完成后关闭客户端socket
    client.connect((HOST, PORT))  # 连接服务端的IP和端口
    client.sendall(b'Hello, world')  # 发送数据
    data = client.recv(1024)
    print('Received',data)
```

# 支持通信循环
虽然上面的代码完成了一个服务端和客户端的连接与数据传输。但是我们知道数据传输之间是相互的，是有问有答的。所以我们需要完善代码，支持数据的循环收发。
```python
# server.py
import socket  # 导入socket模块

HOST = ''                 # Symbolic name meaning all available interfaces
PORT = 50007              # Arbitrary non-privileged port

sock_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 使用socket类创建实例，AF_INET基于IP网络，SOCK_STREAM基于TCP协议
with sock_server:  # 完成后关闭连接socket
    sock_server.bind((HOST, PORT))  # 绑定服务器的通信使用的IP和端口

    sock_server.listen(5)  #开始监听，5代表在允许有五个连接排队，更多的新连接连进来时就会被拒绝
    conn, addr = sock_server.accept() #等待连接。阻塞直到接收连接为止，有了一个新连接进来后，就会为这个请求生成一个连接对象。并可以将链接成功的消息赋值给变量

    print('Connected by', addr)
    with conn:  # 完成后自动关闭数据接收socket
        while True:  # 通信循环
            data = conn.recv(1024) #接收1024个字节。单位bytes。1024是最大接收的限制。
            conn.sendall(data) #把收到的数据再全部返回给客户端
            
# client.py
import socket

HOST = 'localhost'    # The remote host
PORT = 50007              # The same port as used by the server

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
with client:  # 完成后关闭客户端socket
    client.connect((HOST, PORT))  # 连接服务端的IP和端口
    while True:
        msg = input(">>>:").strip()  # 支持客户端输入需要传输消息的内容
        client.sendall(msg.encode('utf-8'))  # 发送数据
        data = client.recv(1024)  # 接收服务端返回的数据
        print('Received',data)
```
通过在服务端和客户端程序中添加while true语句就可以支持循环的数据收发。

## socket编程的bug修复
如上代码虽然完成了基本的需求，但是还有几个重大的bug需要修复
1. time_wait状态
当服务端关闭连接后，我们可能会发现服务端的端口并没有马上关闭，通过使用netstat命令查看端口状态。会发现这个端口处于time_wait状态。这与tcp的四次挥手机制有关。
这回导致一个问题，可能我们尝试重启服务端时，报错端口被占用。在python中通过在bind语句前添加“sock_server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) ”语句。可以解决该问题。
```python
# server.py
import socket  # 导入socket模块

HOST = ''                 # Symbolic name meaning all available interfaces
PORT = 50007              # Arbitrary non-privileged port

sock_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 使用socket类创建实例，AF_INET基于IP网络，SOCK_STREAM基于TCP协议
sock_server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
with sock_server:  # 完成后关闭连接socket
    sock_server.bind((HOST, PORT))  # 绑定服务器的通信使用的IP和端口

    sock_server.listen(5)  #开始监听，5代表在允许有五个连接排队，更多的新连接连进来时就会被拒绝
    conn, addr = sock_server.accept() #等待连接。阻塞直到接收连接为止，有了一个新连接进来后，就会为这个请求生成一个连接对象。并可以将链接成功的消息赋值给变量

    print('Connected by', addr)
    with conn:  # 完成后自动关闭数据接收socket
        while True:
            data = conn.recv(1024) #接收1024个字节。单位bytes。1024是最大接收的限制。
            conn.sendall(data) #把收到的数据再全部返回给客户端
            
```
sock_server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)语句，会让操作系统会在服务器socket被关闭或服务器进程终止后马上释放该服务器的端口，否则操作系统会保留几分钟该端口。
setsockopt方法
setsockopt(level,optname,value)

level定义了哪个选项将被使用。通常情况下是SOL_SOCKET，意思是正在使用的socket选项。它还可以通过设置一个特殊协议号码来设置协议选项，然而对于一个给定的操作系统，大多数协议选项都是明确的，所以为了简便，它们很少用于为移动设备设计的应用程序。

optname参数提供使用的特殊选项。关于可用选项的设置，会因为操作系统的不同而有少许不同。如果level选定了SOL_SOCKET，那么一些常用的选项见下表：

选项，意义，期望值

SO_BINDTODEVICE

可以使socket只在某个特殊的网络接口（网卡）有效。也许不能是移动便携设备

一个字符串给出设备的名称或者一个空字符串返回默认值

SO_BROADCAST

允许广播地址发送和接收信息包。只对UDP有效。如何发送和接收广播信息包

布尔型整数

SO_DONTROUTE

禁止通过路由器和网关往外发送信息包。这主要是为了安全而用在以太网上UDP通信的一种方法。不管目的地址使用什么IP地址，都可以防止数据离开本地网络

布尔型整数

SO_KEEPALIVE

可以使TCP通信的信息包保持连续性。这些信息包可以在没有信息传输的时候，使通信的双方确定连接是保持的

布尔型整数

SO_OOBINLINE

可以把收到的不正常数据看成是正常的数据，也就是说会通过一个标准的对recv()的调用来接收这些数据

布尔型整数

SO_REUSEADDR

当socket关闭后，本地端用于该socket的端口号立刻就可以被重用。通常来说，只有经过系统定义一段时间后，才能被重用。

布尔型整数

 

本节在学习时，用到了SO_REUSEADDR选项，具体写法是：

S.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) 这里value设置为1，表示将SO_REUSEADDR标记为TRUE，操作系统会在服务器socket被关闭或服务器进程终止后马上释放该服务器的端口，否则操作系统会保留几分钟该端口。

2. 当数据为空时，数据的收发暂停。
客户端中的if len(msg) == 0: continue语句。假设没有这个语句，当msg为空时，客户端将空数据send给操作系统请求操作系统将数据从网卡发出，
但操作系统不会将空数据发出。所以服务器recv并不能接收到这个空数据，也就也不会将这个空数据send回客户端。最终导致，客户端和服务端的数据收发被阻塞。
所以为了避免这种阻塞的情况。一定要先检查传输的数据是否为空数据，如果为空不要发出。
```python
# client.py
import socket

HOST = 'localhost'    # The remote host
PORT = 50007              # The same port as used by the server

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
with client:  # 完成后关闭客户端socket
    client.connect((HOST, PORT))  # 连接服务端的IP和端口
    while True:
        msg = input(">>>:").strip()  # 支持客户端输入需要传输消息的内容
        if len(msg) == 0: continue  # 不让产生空数据。因为空数据服务端的recv不会认为接收到了数据，所以也不会send数据。
        client.sendall(msg.encode('utf-8'))  # 发送数据
        data = client.recv(1024)  # 接收服务端返回的数据
        print('Received',data)
```
 
3. 当客户端终止连接后，服务端进入死循环
当客户端终止与服务端的连接后，服务端应为设置了while True的原因，会导致出现死循环。linux系统会陷入死循环，而windows系统会报出ConnectionResetError。所以当客户端断开连接后，我们要终止死循环。
linux系统：通过检测数据是否为空的方式退出死循环。
```python
# server.py
import socket  # 导入socket模块

HOST = ''                 # Symbolic name meaning all available interfaces
PORT = 50007              # Arbitrary non-privileged port

sock_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 使用socket类创建实例，AF_INET基于IP网络，SOCK_STREAM基于TCP协议
sock_server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
with sock_server:  # 完成后关闭连接socket
    sock_server.bind((HOST, PORT))  # 绑定服务器的通信使用的IP和端口

    sock_server.listen(5)  #开始监听，‘5’代表在操作系统可以挂起的最大连接数量。只有5个连接可以进行处理，大于5的新连接连进来时就会被拒绝。也就说，可以有5个客户端在队列中排队等待处理，多于5个的客户端将不能连接。
    conn, addr = sock_server.accept() #等待连接。阻塞直到接收连接为止，有了一个新连接进来后，就会为这个请求生成一个连接对象。并可以将链接成功的消息赋值给变量

    print('Connected by', addr)
    with conn:  # 完成后自动关闭数据接收socket
        while True:
            data = conn.recv(1024) #接收1024个字节。单位bytes。1024是最大接收的限制。
            if not data: break  # 如果没有接收到数据的时候，直接关闭连接，服务端退出。
            conn.sendall(data) #把收到的数据再全部返回给客户端
```
通过if not data: break语句。但客户端关闭连接后，服务端也会退出。虽然避免了死循环。但也不合理。服务端不应该由于客户端的断开，而中止自己的服务。
windows系统：通过使用异常处理的方法退出死循环。
```python
import socket  # 导入socket模块

HOST = ''                 # Symbolic name meaning all available interfaces
PORT = 50007              # Arbitrary non-privileged port

sock_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 使用socket类创建实例，AF_INET基于IP网络，SOCK_STREAM基于TCP协议
sock_server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
with sock_server:  # 完成后关闭连接socket
    sock_server.bind((HOST, PORT))  # 绑定服务器的通信使用的IP和端口

    sock_server.listen(5)  #开始监听，5代表在允许有五个连接排队，更多的新连接连进来时就会被拒绝
    conn, addr = sock_server.accept() #等待连接。阻塞直到接收连接为止，有了一个新连接进来后，就会为这个请求生成一个连接对象。并可以将链接成功的消息赋值给变量

    print('Connected by', addr)
    with conn:  # 完成后自动关闭数据接收socket
        while True:
            try:
                data = conn.recv(1024) #接收1024个字节。单位bytes。1024是最大接收的限制。
                if not data: break
                print(conn,data)
                conn.sendall(data) #把收到的数据再全部返回给客户端
            except ConnectionResetError:
                break
```
# 服务端可以和多个客户端进行通信
如上代码，虽然解决的当客户端退出后会导致的死循环问题，但当客户端退出的同时，服务端也退出了。这显然是不合理的。毕竟有谁开发的服务端会因为客户端的退出，而自己退出服务哪？
通过在accept函数前增加while True循环的方式，增加一个连接循环。可以实现当一个客户端退出后，处理新客户端的数据传输。
```python
server.py
import socket  # 导入socket模块

HOST = ''                 # Symbolic name meaning all available interfaces
PORT = 50007              # Arbitrary non-privileged port

sock_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 使用socket类创建实例，AF_INET基于IP网络，SOCK_STREAM基于TCP协议
sock_server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
with sock_server:  # 完成后关闭连接socket
    sock_server.bind((HOST, PORT))  # 绑定服务器的通信使用的IP和端口

    sock_server.listen(5)  #开始监听，5代表在允许有五个连接排队，更多的新连接连进来时就会被拒绝
    while True:  # 添加一个连接循环，当一个客户端退出后，会返回到这里。并等待另一个客户端的连接。
        conn, addr = sock_server.accept() #等待连接。阻塞直到接收连接为止，有了一个新连接进来后，就会为这个请求生成一个连接对象。并可以将链接成功的消息赋值给变量

        print('Connected by', addr)
        with conn:  # 完成后自动关闭数据接收socket
            while True:
                try:
                    data = conn.recv(1024) #接收1024个字节。单位bytes。1024是最大接收的限制。
                    if not data: break
                    print(conn,data)
                    conn.sendall(data) #把收到的数据再全部返回给客户端
                except ConnectionResetError:
                    break
```

如上代码并没有并发的作用，一次只能支持一个客户端收发数据。并发处理的方式，在进行与线程章节讲解。

# TCP粘包问题
在讲解TCP粘包问题之前，我们先来写一个模仿ssh执行命令的服务端和客户端程序。
## 编写一个ssh命令执行
```python
# server.py
import socket
import subprocess

ip_port = ('127.0.0.1', 8083)


tcp_socket_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcp_socket_server.bind(ip_port)
tcp_socket_server.listen(5)

while True:
    conn, addr = tcp_socket_server.accept()
    print('客户端', addr)

    while True:
        cmd = conn.recv(1024)
        if len(cmd) == 0: break
        print("recv cmd",cmd)
        res = subprocess.Popen(cmd.decode('utf-8'), shell=True,
                               stdout=subprocess.PIPE,
                               stdin=subprocess.PIPE,
                               stderr=subprocess.PIPE)

        stderr = res.stderr.read()
        stdout = res.stdout.read()
        conn.send(stderr + stdout)
# client.py
import socket
ip_port = ('127.0.0.1', 8083)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
res = s.connect_ex(ip_port)

while True:
    msg = input('>>: ').strip()
    if len(msg) == 0: continue
    if msg == 'quit': break

    s.send(msg.encode('utf-8'))
    act_res = s.recv(1024)

    print(act_res.decode('utf-8'), end='')
```
如上代码，如果你执行ifconfig命令或发现一个严重的问题。
```python
>>: ifconfig
ifconfig
eno16777736: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.153.139  netmask 255.255.255.0  broadcast 192.168.153.255
        inet6 fe80::20c:29ff:fea7:6dde  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:a7:6d:de  txqueuelen 1000  (Ethernet)
        RX packets 177  bytes 16530 (16.1 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 215  bytes 20328 (19.8 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

eno33554960: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.25.0.10  netmask 255.255.255.0  broadcast 172.25.0.255
        inet6 fe80::20c:29ff:fea7:6de8  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:a7:6d:e8  txqueuelen 1000  (Ethernet)
        RX packets 886  bytes 678744 (662.8 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 501  bytes 71343 (69.6 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 6553>>: 

>>: 

>>: if
if
6
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1  (Local Loopback)
        RX packets 78195  bytes 37689056 (35.9 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 78195  bytes 37689056 (35.9 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

virbr0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255
        ether 52:54:00:12:c9:7a  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

>>: ls
ls
/bin/sh: -c: line 1: syntax error: unexpected end of file
```
为什么ifconfig命令执行后，输出的内容被切分成了三次显示。
## 粘包现象原理
粘包现象有两个原因：
　　（1）发送方原因

　　粘包现象与TCP协议的传输优化算法（Nagle算法）有关。nagle算法是TCP的一种优化传输的优化算法，它会将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包后发送。
为什么要这样做？因为如果发送端一个字节一个字节的发送数据包， 软件传输需要经过网卡、网线等多个物理设备，数据包在网络传输过程的会损失很多的时间。所以这种频繁传输小数据的传输方式，明显没有任何的效率可言，甚至可能导致网络拥塞的问题。
TCP使用Nagle算法，将间隔较小且数据量较小的数据合并成一个大数据包，是为了减少广域网的小分组数目，从而减小网络拥塞的出现。但是Nagle算法合并包时，没有对包的边界进行区分。最终导致接收端也无法区分包的边界。

　　（2）接收方原因

　　TCP接收到分组时，并不会立刻送至应用层处理，或者说，应用层并不一定会立即处理；实际上，TCP将收到的分组保存至接收缓存里，然后应用程序主动从缓存里读收到的分组。这样一来，如果TCP接收分组的速度大于应用程序读分组的速度，多个包就会被存至缓存，应用程序读时，就会读到多个首尾相接粘到一起的包。

我们通过如下2个代码来看一下这两种原因：
```python
# server.py
import socket
import subprocess

ip_port = ('127.0.0.1', 8080)

tcp_socket_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcp_socket_server.bind(ip_port)
tcp_socket_server.listen(5)

conn, addr = tcp_socket_server.accept()
print('第一次接收',conn.recv(1024))  # 查看第一次接收的数据
print('第二次接收',conn.recv(1024))  # 查看第二次接收的数据

# client.py
import socket
ip_port = ('127.0.0.1', 8080)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
res = s.connect_ex(ip_port)

s.send(b'hello')  # 发送小数据
s.send(b'world')  # 发送小数据
# 由于这两个数据非常的小，并且相隔时间较短。所以会产生粘包后才将数据发送给服务端
```
#### 输出内容
```text
第一次接收 b'helloworld'
第二次接收 b''
```
我们可以发现服务端接收到的是客户端粘包后的数据。
```python
# server.py
import socket, time
ip_port = ('127.0.0.1', 8080)

tcp_socket_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcp_socket_server.bind(ip_port)
tcp_socket_server.listen(5)

conn, addr = tcp_socket_server.accept()
print('第一次接收',conn.recv(1))  # 减少resv接收的字节数
time.sleep(6)  # 让服务端暂停6秒，大于客户端的5秒。这时会产生粘包
print('第二次接收',conn.recv(1024))
# client.py
import socket,time
ip_port = ('127.0.0.1', 8080)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
res = s.connect_ex(ip_port)

s.send(b'hello')
time.sleep(1)  # 增加时间间隔，不让客户端粘包
s.send(b'world')
```
#### 输出结果
```text
第一次接收 b'h'
第二次接收 b'elloworld'
```
3 什么时候需要处理粘包现象
　　（1）如果发送方发送的多个分组本来就是同一个数据的不同部分，比如一个很大的文件被分成多个分组发送，这时，当然不需要处理粘包的现象；

　　（2）但如果多个分组本毫不相干，甚至是并列的关系，我们就一定要处理粘包问题了。比如，我当时要接收的每个分组都是一个有固定格式的商品信息，如果不处理粘包问题，每个读进来的分组我只会处理最前边的那个商品，后边的就会被丢弃。这显然不是我要的结果。

# 解决粘包问题的方法

可能大家会想到直接把recv(1024)改大不就好了，改成5000\10000或更大. 但是，并不能解决实际问题，因为你不可能提前知道对方返回的结果数据大下，无论你改成多大，
对方的结果也有可能比你设置的大。另外这个recv并不是真的可以随便改特别大的，因为IO缓存的大小是操作系统定义好的，就算recv很大，IO缓存的大小限制还在。
并且，建议的不要超过8192，再大反而会出现影响收发速度和不稳定的情况。
那解决粘包的问题吶？是否在发送数据前加上自己定义个报头，这个报头中明确告知接收方数据的长度，这样接收方就可以根据长度来判断该如何处理数据。
这里就引出了struct模块。
2. 简单版本。
该版本自定义一个报头信息，服务端将数据的长度传给客户端
```python
# server.py
import socket
import struct

ip_port = ('127.0.0.1', 8084)
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect_ex(ip_port)

while True:
    msg = input('>>: ').strip()
    if len(msg) == 0: continue
    if msg == 'quit': break

    client.send(msg.encode('utf-8'))
    # 第一步：收取报头，
    head = client.recv(4)  # 由于struct.pack的报头是4个字节。所以这里肯定数据的前4个字节就是报头。

    # 第二步：并将报头的数据解开。并且获取数据的大小
    totle_size = struct.unpack('i', head)[0]  # head=s.recv(4)返回的是一个元组。第一位就是数据的字节数

    res_size = 0
    res_data = b''
    while res_size < totle_size:  # 设置一个循环。当接收数据的大小小于数据的总大小时，会一直循环，知道数据全部处理完成。
        res = client.recv(1024)  # 每次接收1024字节的数据
        res_data += res  # 将每次获得的数据内容进行相加
        res_size += len(res)  # 每次对真实获得数据的大小进行相加

    # 当循环处理完后，打印最后的结果。
    print(res_data.decode('utf-8'))
    
# client.py
import socket
import struct

ip_port = ('127.0.0.1', 8084)
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect_ex(ip_port)

while True:
    msg = input('>>: ').strip()
    if len(msg) == 0: continue
    if msg == 'quit': break

    client.send(msg.encode('utf-8'))
    # 第一步：收取报头，
    head = client.recv(4)  # 由于struct.pack的报头是4个字节。所以这里肯定数据的前4个字节就是报头。

    # 第二步：并将报头的数据解开。并且获取数据的大小
    totle_size = struct.unpack('i', head)[0]  # head=s.recv(4)返回的是一个元组。第一位就是数据的字节数

    res_size = 0
    res_data = b''
    while res_size < totle_size:  # 设置一个循环。当接收数据的大小小于数据的总大小时，会一直循环，知道数据全部处理完成。
        res = client.recv(1024)  # 每次接收1024字节的数据
        res_data += res  # 将每次获得的数据内容进行相加
        res_size += len(res)  # 每次对真实获得数据的大小进行相加

    # 当循环处理完后，打印最后的结果。
    print(res_data.decode('utf-8'))
```

3. 增强版本模块
上面的代码还是有问题的。
1. 当传输文件时，数据的报头除了长度。应该还有文件名称、md5值等校验信息。
2. sturet模块的i代码整形模式、L代表长整型模式，都是有范围空间的，不可能无限制大。但文件的大小是不可控的。
可以通过在程序中先制定自己的报头的格式，并使用struct先将这个报头的大小告知接收方，接收方通过解析出这个报头的内容。来获取数据大小、文件名称、md5值等消息。
```python

# server.py
import socket
import subprocess
import struct
import json
import hashlib

md5 = hashlib.md5()
ip_port = ('127.0.0.1', 8085)
tcp_socket_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcp_socket_server.bind(ip_port)
tcp_socket_server.listen(5)

while True:
    conn, addr = tcp_socket_server.accept()
    print('客户端', addr)

    while True:
        cmd = conn.recv(1024)
        if len(cmd) == 0: break
        print("recv cmd",cmd)
        res = subprocess.Popen(cmd.decode('utf-8'), shell=True,
                               stdout=subprocess.PIPE,
                               stdin=subprocess.PIPE,
                               stderr=subprocess.PIPE)

        err = res.stderr.read()
        if err:  # 判断是否有错误信息。如有错误信息，返回的错误信息，除此返回正常的输出结果
            res_out = err
        else:
            res_out = res.stdout.read()
            md5 = hashlib.md5(res_out)  # 将数据使用MD5进行校验。产生一个MD5的对象

        # 第一步：指定一个自己的报头信息
        header_dict = {'filename': 'test',
                       'size': len(res_out),
                       'md5': md5.hexdigest()}  # 制定一个自己设计的报头信息
        print(header_dict)
        header_json = json.dumps(header_dict)  # 将字典格式转换为字符串格式
        header_bytes = header_json.encode('utf-8')  # 将字符串格式转换为字节格式

        # 第二步：发送报头信息的长度
        conn.send(struct.pack('i',len(header_bytes)))  # 使用struct.pack将报头的长度信息封装成4个字节。并发送给客户端

        # 第三步： 发送报头信息
        conn.send(header_bytes)

        # 第四步：发送真实的数据。
        conn.send(res_out)
    conn.close()
# client.py
import socket
import struct
import json

ip_port = ('127.0.0.1', 8085)
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect_ex(ip_port)

while True:
    msg = input('>>: ').strip()
    if len(msg) == 0: continue
    if msg == 'quit': break

    client.send(msg.encode('utf-8'))
    # 第一步：获取报头的长度
    head = client.recv(4)  # 由于struct.pack的封装后的大小4个字节。所以这里肯定先接收，数据的前4个字节。
    header_size = struct.unpack('i', head)[0]  # head=s.recv(4)返回的是一个元组。第一位就是报头信息的字节数

    # 第二步：再收报头信息
    header_bytes = client.recv(header_size)

    # 第三步：解析报头信息
    header_json = header_bytes.decode('utf-8')  # 对字节格式反编码为utf-8
    header_dict = json.loads(header_json)  # 重新加载为json格式
    print(header_dict)
    totle_size = header_dict['size']  # 解析出了数据的真实大小

    res_size = 0
    res_data = b''
    while res_size < totle_size:  # 设置一个循环。当接收数据的大小小于数据的总大小时，会一直循环，知道数据全部处理完成。
        res = client.recv(1024)  # 每次接收1024字节的数据
        res_data += res  # 将每次获得的数据内容进行相加
        res_size += len(res)  # 每次对真实获得数据的大小进行相加

    # 当循环处理完后，打印最后的结果。
    print(res_data.decode('utf-8'))
```


# socket文件传输
在上面的代码中稍加改动，支持文件下载和传输。

```python
服务端实现
import socket
import struct
import json
import subprocess
import os

class MYTCPServer:
    address_family = socket.AF_INET

    socket_type = socket.SOCK_STREAM

    allow_reuse_address = False

    max_packet_size = 8192

    coding='utf-8'

    request_queue_size = 5

    server_dir='file_upload'

    def __init__(self, server_address, bind_and_activate=True):
        """Constructor.  May be extended, do not override."""
        self.server_address=server_address
        self.socket = socket.socket(self.address_family,
                                    self.socket_type)
        if bind_and_activate:
            try:
                self.server_bind()
                self.server_activate()
            except:
                self.server_close()
                raise

    def server_bind(self):
        """Called by constructor to bind the socket.
        """
        if self.allow_reuse_address:
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket.bind(self.server_address)
        self.server_address = self.socket.getsockname()

    def server_activate(self):
        """Called by constructor to activate the server.
        """
        self.socket.listen(self.request_queue_size)

    def server_close(self):
        """Called to clean-up the server.
        """
        self.socket.close()

    def get_request(self):
        """Get the request and client address from the socket.
        """
        return self.socket.accept()

    def close_request(self, request):
        """Called to clean up an individual request."""
        request.close()

    def run(self):
        while True:
            self.conn,self.client_addr=self.get_request()
            print('from client ',self.client_addr)
            while True:
                try:
                    head_struct = self.conn.recv(4)
                    if not head_struct:break

                    head_len = struct.unpack('i', head_struct)[0]
                    head_json = self.conn.recv(head_len).decode(self.coding)
                    head_dic = json.loads(head_json)

                    print(head_dic)
                    #head_dic={'cmd':'put','filename':'a.txt','filesize':123123}
                    cmd=head_dic['cmd']
                    if hasattr(self,cmd):
                        func=getattr(self,cmd)
                        func(head_dic)
                except Exception:
                    break

    def put(self,args):
        file_path=os.path.normpath(os.path.join(
            self.server_dir,
            args['filename']
        ))

        filesize=args['filesize']
        recv_size=0
        print('----->',file_path)
        with open(file_path,'wb') as f:
            while recv_size < filesize:
                recv_data=self.conn.recv(self.max_packet_size)
                f.write(recv_data)
                recv_size+=len(recv_data)
                print('recvsize:%s filesize:%s' %(recv_size,filesize))


tcpserver1=MYTCPServer(('127.0.0.1',8080))

tcpserver1.run()
客户端实现
import socket
import struct
import json
import os



class MYTCPClient:
    address_family = socket.AF_INET

    socket_type = socket.SOCK_STREAM

    allow_reuse_address = False

    max_packet_size = 8192

    coding='utf-8'

    request_queue_size = 5

    def __init__(self, server_address, connect=True):
        self.server_address=server_address
        self.socket = socket.socket(self.address_family,
                                    self.socket_type)
        if connect:
            try:
                self.client_connect()
            except:
                self.client_close()
                raise

    def client_connect(self):
        self.socket.connect(self.server_address)

    def client_close(self):
        self.socket.close()

    def run(self):
        while True:
            inp=input(">>: ").strip()
            if not inp:continue
            l=inp.split()
            cmd=l[0]
            if hasattr(self,cmd):
                func=getattr(self,cmd)
                func(l)


    def put(self,args):
        cmd=args[0]
        filename=args[1]
        if not os.path.isfile(filename):
            print('file:%s is not exists' %filename)
            return
        else:
            filesize=os.path.getsize(filename)

        head_dic={'cmd':cmd,'filename':os.path.basename(filename),'filesize':filesize}
        print(head_dic)
        head_json=json.dumps(head_dic)
        head_json_bytes=bytes(head_json,encoding=self.coding)

        head_struct=struct.pack('i',len(head_json_bytes))
        self.socket.send(head_struct)
        self.socket.send(head_json_bytes)
        send_size=0
        with open(filename,'rb') as f:
            for line in f:
                self.socket.send(line)
                send_size+=len(line)
                print(send_size)
            else:
                print('upload successful')




client=MYTCPClient(('127.0.0.1',8080))

client.run()
```

# UDP协议socket
udp 不需要经过3次握手和4次挥手，不需要提前建立连接，直接发数据就行。
所以不需要使用listen和accept。

server端
```python
import socket
ip_port=('127.0.0.1',9000)
BUFSIZE=1024
udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #udp类型

udp_server_client.bind(ip_port)  # 绑定服务器的IP和端口

while True:  # 数据循环
    msg,addr=udp_server_client.recvfrom(BUFSIZE)  # 收数据后，recvfrom方法会产生消息内容和客户端IP端口的对象
    print("recv ",msg,addr)

    udp_server_client.sendto(msg.upper(),addr)  # 发消息时，sendto方法需要，数据和客户端的IP和端口
```

client端
```python
import socket
ip_port = ('127.0.0.1',9000)  # 服务端的IP和端口
BUFSIZE = 1024
udp_server_client = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

while True:
    msg=input('>>: ').strip()
    if not msg:continue
    udp_server_client.sendto(msg.encode('utf-8'),ip_port)  # 将数据发给服务端

    back_msg,addr = udp_server_client.recvfrom(BUFSIZE)
    print(back_msg.decode('utf-8'),addr)
```
TCP VS UDP的区别：
tcp基于链接通信
- 基于链接，则需要listen（backlog），指定连接池的大小
- 基于链接，必须先运行的服务端，然后客户端发起链接请求
- 对于mac系统：如果一端断开了链接，那另外一端的链接也跟着完蛋recv将不会阻塞，收到的是空(解决方法是：服务端在收消息后加上if判断，空消息就break掉通信循环)
- 对于windows/linux系统：如果一端断开了链接，那另外一端的链接也跟着完蛋recv将不会阻塞，收到的是空(解决方法是：服务端通信循环内加异常处理，捕捉到异常后就break掉通讯循环)
- TCP会有粘包现象
udp无链接
- 无链接，因而无需listen（backlog），更加没有什么连接池之说了
- 无链接，udp的sendinto不用管是否有一个正在运行的服务端，可以己端一个劲的发消息，只不过数据丢失
- recvfrom收的数据小于sendinto发送的数据时，在mac和linux系统上数据直接丢失，在windows系统上发送的比接收的大直接报错
- UDP是一发一收的方式，所有如果只有sendinto发送数据没有recvfrom收数据，数据丢失
- UDP由于是基于数据包所以不会有粘包。

# 作业
---
作业题目(一)：开发一套选课系统

作业需求：

角色:学校、学员、课程、讲师

要求:

1. 创建北京、上海 2 所学校

2. 创建linux , python , go 3个课程，linux\py在北京开， go 在上海开

3. 课程包含，周期，价格，通过学校创建课程

4. 通过学校创建班级，班级关联课程、讲师

5. 创建学员时，选择学校，关联班级

5. 创建讲师角色时要关联学校，

6. 提供两个角色接口

6.1 学员视图，可以注册，交学费，选择班级，

6.2 讲师视图，讲师可管理自己的班级，上课时选择班级，查看班级学员列表，修改所管理的学员的成绩

6.3 管理视图，创建讲师，创建班级，创建课程

 

7. 上面的操作产生的数据都通过pickle序列化保存到文件里
作业题目(一)：开发一个支持多用户在线的FTP程序

作业需求：

要求：

1.用户加密认证  # hashlib模块对用户名密码进行加密。
2.允许同时多用户登录
3.每个用户有自己的家目录，且只能访问自己的家目录  # 使用用户名在配置文件的固定目录中添加用户名的目录。并可以实现ls，dir功能
4.对用户进行磁盘配额，每个用户的可用空间不同 # 使用os模块检查用户目录的空间+上文件大小，如果大于quota就不让传输。
5.允许用户在ftp server上随意切换目录 cd功能 记录用户输入的目录，进行目录的拼接。
6.允许用户查看当前目录下文件 ls功能
7.允许上传和下载文件，保证文件一致性(md5)
8.文件传输过程中显示进度条
9.附加功能：支持文件的断点续传。比较客户端文件与服务端文件的bytes，如果不一致。客户端、服务端就使用文件seek方法移动光标。续传。

